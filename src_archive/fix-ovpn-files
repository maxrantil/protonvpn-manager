#!/bin/bash
# ABOUTME: OpenVPN file repair utility for Artix/Arch Linux VPN management
# ABOUTME: Detects and repairs corrupted OpenVPN configuration files

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
# Allow override for testing via environment variable
LOCATIONS_DIR="${LOCATIONS_DIR:-$PROJECT_ROOT/locations}"
readonly BACKUP_DIR="${LOCATIONS_DIR}/backups"

# Colors
readonly RED='\033[1;31m'
readonly GREEN='\033[1;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[1;36m'
readonly NC='\033[0m'

print_banner() {
	echo -e "${BLUE}╔════════════════════════════════════════╗${NC}"
	echo -e "${BLUE}║      OpenVPN File Repair Utility      ║${NC}"
	echo -e "${BLUE}║     Corruption Detection & Repair     ║${NC}"
	echo -e "${BLUE}╚════════════════════════════════════════╝${NC}"
	echo
}

show_help() {
	print_banner
	echo -e "${YELLOW}Usage: fix-ovpn-files [options]${NC}"
	echo
	echo "Options:"
	echo "  --check     Check which files need repair (dry run)"
	echo "  --repair    Repair corrupted files"
	echo "  --backup    Create backups before repair (default: enabled)"
	echo "  --no-backup Skip backup creation"
	echo "  --directory DIR  Specify directory to process (default: locations/)"
	echo "  --help      Show this help message"
	echo
	echo "Detected issues and repairs:"
	echo "  • Missing client directive"
	echo "  • Malformed remote directives"
	echo "  • Missing essential configuration"
	echo "  • Binary corruption detection"
	echo
}

check_dependencies() {
	if [[ ! -d "$LOCATIONS_DIR" ]]; then
		echo -e "${RED}Error: Locations directory not found: $LOCATIONS_DIR${NC}"
		return 1
	fi

	local ovpn_count
	ovpn_count=$(find "$LOCATIONS_DIR" -name "*.ovpn" 2>/dev/null | wc -l)

	if [[ $ovpn_count -eq 0 ]]; then
		echo -e "${YELLOW}No .ovpn files found in $LOCATIONS_DIR${NC}"
		return 1
	fi

	echo -e "${GREEN}Found $ovpn_count .ovpn files to process${NC}"
	return 0
}

is_binary_file() {
	local file="$1"

	# Check for OpenVPN-specific corruption patterns
	# Look for specific characters that indicate corruption
	if grep -q "ÿ\|ø\|§" "$file" 2>/dev/null; then
		return 0 # Is corrupted/binary
	fi

	# Check for null bytes
	if grep -qz $'\0' "$file" 2>/dev/null; then
		return 0 # Contains null bytes
	fi

	return 1 # Not binary
}

validate_ovpn_config() {
	local ovpn_file="$1"
	local issues=""

	# Debug output - remove this later
	# echo "DEBUG: Validating $ovpn_file" >&2

	# Check if file exists and is readable
	if [[ ! -r "$ovpn_file" ]]; then
		echo "UNREADABLE"
		return 1
	fi

	# Check if file is binary/corrupted - look for specific corruption patterns
	if grep -q "ÿ\|ø\|§" "$ovpn_file" 2>/dev/null; then
		echo "BINARY_CORRUPTION"
		return 1
	fi

	# SECURITY: Check for potentially malicious content
	if grep -qE "(exec|system|\`|\\\$\\\(|\.\.\\/|~\\/|;|&|\\\|)" "$ovpn_file" 2>/dev/null; then
		echo "SUSPICIOUS_CONTENT"
		return 1
	fi

	# SECURITY: Validate reasonable file size (prevent resource exhaustion)
	local file_size
	file_size=$(stat -c%s "$ovpn_file" 2>/dev/null || echo "0")
	if [[ $file_size -gt 1048576 ]]; then # 1MB limit
		echo "FILE_TOO_LARGE"
		return 1
	fi

	# Check for essential directives
	if ! grep -q "^client" "$ovpn_file" 2>/dev/null; then
		issues="${issues}MISSING_CLIENT "
	fi

	if ! grep -q "^remote.*[0-9]" "$ovpn_file" 2>/dev/null; then
		if grep -q "^remote[[:space:]]*$" "$ovpn_file" 2>/dev/null; then
			issues="${issues}MALFORMED_REMOTE "
		else
			issues="${issues}MISSING_REMOTE "
		fi
	fi

	# Check for at least some basic configuration
	if ! grep -qE "^(dev|proto|cipher|auth)" "$ovpn_file" 2>/dev/null; then
		issues="${issues}INCOMPLETE_CONFIG "
	fi

	if [[ -n "$issues" ]]; then
		echo "${issues% }" # Remove trailing space
		return 1
	fi

	echo "VALID"
	return 0
}

can_repair() {
	local issues="$1"

	# Security issues cannot be repaired
	if [[ "$issues" =~ BINARY_CORRUPTION|SUSPICIOUS_CONTENT|FILE_TOO_LARGE|UNREADABLE ]]; then
		return 1
	fi

	# Some specific issues can be repaired
	if [[ "$issues" =~ MISSING_CLIENT|MALFORMED_REMOTE ]]; then
		return 0
	fi

	# Incomplete config might be repairable depending on what's missing
	return 1
}

create_backup() {
	local ovpn_file="$1"

	# SECURITY: Create backup directory with restrictive permissions
	if ! mkdir -p "$BACKUP_DIR" || ! chmod 700 "$BACKUP_DIR"; then
		echo -e "${RED}Error: Failed to create secure backup directory${NC}"
		return 1
	fi

	local backup_file="$BACKUP_DIR/$(basename "$ovpn_file").backup.$(date +%Y%m%d_%H%M%S)"

	if cp "$ovpn_file" "$backup_file"; then
		# SECURITY: Set restrictive permissions on backup file
		chmod 600 "$backup_file"
		echo "  Backup created: $backup_file"
		return 0
	else
		echo -e "${RED}Error: Failed to create backup for $(basename "$ovpn_file")${NC}"
		return 1
	fi
}

repair_ovpn_file() {
	local ovpn_file="$1"
	local issues="$2"
	local create_backup_flag="$3"

	echo -e "${BLUE}Repairing: $(basename "$ovpn_file")${NC}"

	# Create backup if requested
	if [[ "$create_backup_flag" == "true" ]]; then
		if ! create_backup "$ovpn_file"; then
			return 1
		fi
	fi

	# SECURITY: Create temporary file with secure permissions
	local temp_file
	temp_file=$(mktemp) || {
		echo -e "${RED}Error: Failed to create secure temporary file${NC}"
		return 1
	}

	# SECURITY: Set restrictive permissions immediately
	chmod 600 "$temp_file" || {
		rm -f "$temp_file"
		echo -e "${RED}Error: Failed to secure temporary file${NC}"
		return 1
	}

	# SECURITY: Ensure cleanup on exit
	trap 'rm -f "$temp_file"' EXIT

	# Copy original content
	cp "$ovpn_file" "$temp_file"

	# Apply repairs based on detected issues
	if [[ "$issues" =~ MISSING_CLIENT ]]; then
		# Add client directive at the beginning
		sed -i '1i\client' "$temp_file"
		echo "  Added: client directive"
	fi

	if [[ "$issues" =~ MALFORMED_REMOTE ]]; then
		# Try to fix malformed remote lines by removing empty ones
		sed -i '/^remote\s*$/d' "$temp_file"
		echo "  Removed: malformed remote directive"
	fi

	# Replace original file with repaired version
	if mv "$temp_file" "$ovpn_file"; then
		echo -e "${GREEN}  ✓ REPAIRED: $(basename "$ovpn_file")${NC}"
		return 0
	else
		echo -e "${RED}  ✗ FAILED to repair: $(basename "$ovpn_file")${NC}"
		rm -f "$temp_file"
		return 1
	fi
}

check_files() {
	echo -e "${BLUE}Checking .ovpn files for corruption and issues...${NC}"
	echo

	local files_valid=0
	local files_repairable=0
	local files_unrepairable=0

	while IFS= read -r -d '' ovpn_file; do
		local issues
		issues=$(validate_ovpn_config "$ovpn_file") || true

		if [[ "$issues" == "VALID" ]]; then
			echo -e "${GREEN}VALID:${NC} $(basename "$ovpn_file")"
			files_valid=$((files_valid + 1))
		elif can_repair "$issues"; then
			echo -e "${YELLOW}REPAIRABLE:${NC} $(basename "$ovpn_file") ($issues)"
			files_repairable=$((files_repairable + 1))
		else
			echo -e "${RED}UNREPAIRABLE:${NC} $(basename "$ovpn_file") ($issues)"
			files_unrepairable=$((files_unrepairable + 1))
		fi
	done < <(find "$LOCATIONS_DIR" -name "*.ovpn" -print0)

	echo
	echo -e "${BLUE}Check Summary:${NC}"
	echo -e "  Valid files: ${GREEN}$files_valid${NC}"
	echo -e "  Repairable files: ${YELLOW}$files_repairable${NC}"
	echo -e "  Unrepairable files: ${RED}$files_unrepairable${NC}"
}

repair_all_files() {
	local create_backup_flag="$1"

	echo -e "${BLUE}Repairing all correctable .ovpn files...${NC}"
	echo

	local repaired_count=0
	local error_count=0
	local skipped_count=0

	while IFS= read -r -d '' ovpn_file; do
		local issues
		issues=$(validate_ovpn_config "$ovpn_file") || true

		if [[ "$issues" == "VALID" ]]; then
			echo -e "${GREEN}SKIP: $(basename "$ovpn_file") (already valid)${NC}"
			skipped_count=$((skipped_count + 1))
		elif can_repair "$issues"; then
			if repair_ovpn_file "$ovpn_file" "$issues" "$create_backup_flag"; then
				repaired_count=$((repaired_count + 1))
			else
				error_count=$((error_count + 1))
			fi
		else
			echo -e "${RED}UNREPAIRABLE: $(basename "$ovpn_file") ($issues)${NC}"
			error_count=$((error_count + 1))
		fi
		echo
	done < <(find "$LOCATIONS_DIR" -name "*.ovpn" -print0)

	echo -e "${BLUE}Repair Summary:${NC}"
	echo -e "  Files repaired: ${GREEN}$repaired_count${NC}"
	echo -e "  Files skipped: ${YELLOW}$skipped_count${NC}"
	echo -e "  Errors/Unrepairable: ${RED}$error_count${NC}"

	if [[ $error_count -eq 0 ]]; then
		echo -e "${GREEN}✓ All repairable files fixed successfully!${NC}"
		return 0
	else
		echo -e "${YELLOW}⚠ Some files could not be repaired. Check output above.${NC}"
		return 1
	fi
}

main() {
	local check_only=false
	local repair_mode=false
	local create_backup=true

	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
		--check)
			check_only=true
			shift
			;;
		--repair)
			repair_mode=true
			shift
			;;
		--backup)
			create_backup=true
			shift
			;;
		--no-backup)
			create_backup=false
			shift
			;;
		--directory)
			# SECURITY: Validate and canonicalize directory path
			local requested_dir="$2"
			if [[ -z "$requested_dir" ]]; then
				echo -e "${RED}Error: --directory requires a path${NC}"
				exit 1
			fi

			# Resolve canonical path and validate it exists
			LOCATIONS_DIR="$(realpath "$requested_dir" 2>/dev/null)" || {
				echo -e "${RED}Error: Directory validation failed${NC}"
				exit 1
			}

			# SECURITY: Ensure directory is within project scope to prevent traversal attacks
			local project_real="$(realpath "$PROJECT_ROOT" 2>/dev/null)"
			if [[ ! "$LOCATIONS_DIR" =~ ^"$project_real" ]]; then
				echo -e "${RED}Error: Directory must be within project scope${NC}"
				exit 1
			fi

			shift 2
			;;
		--help | -h)
			show_help
			exit 0
			;;
		*)
			echo -e "${RED}Unknown option: $1${NC}"
			show_help
			exit 1
			;;
		esac
	done

	print_banner

	if ! check_dependencies; then
		exit 1
	fi

	echo

	if [[ "$check_only" == "true" ]]; then
		check_files
	elif [[ "$repair_mode" == "true" ]]; then
		repair_all_files "$create_backup"
	else
		# Default behavior: check first
		check_files
	fi
}

# Only run if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
