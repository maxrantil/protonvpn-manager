#!/bin/bash
# ABOUTME: OpenVPN file repair utility for Artix/Arch Linux VPN management
# ABOUTME: Detects and repairs corrupted OpenVPN configuration files

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
# Allow override for testing via environment variable
LOCATIONS_DIR="${LOCATIONS_DIR:-$PROJECT_ROOT/locations}"
readonly BACKUP_DIR="${LOCATIONS_DIR}/backups"

# Colors
readonly RED='\033[1;31m'
readonly GREEN='\033[1;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[1;36m'
readonly NC='\033[0m'

print_banner() {
    echo -e "${BLUE}╔════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║      OpenVPN File Repair Utility      ║${NC}"
    echo -e "${BLUE}║     Corruption Detection & Repair     ║${NC}"
    echo -e "${BLUE}╚════════════════════════════════════════╝${NC}"
    echo
}

show_help() {
    print_banner
    echo -e "${YELLOW}Usage: fix-ovpn-files [options]${NC}"
    echo
    echo "Options:"
    echo "  --check     Check which files need repair (dry run)"
    echo "  --repair    Repair corrupted files"
    echo "  --backup    Create backups before repair (default: enabled)"
    echo "  --no-backup Skip backup creation"
    echo "  --directory DIR  Specify directory to process (default: locations/)"
    echo "  --help      Show this help message"
    echo
    echo "Detected issues and repairs:"
    echo "  • Missing client directive"
    echo "  • Malformed remote directives"
    echo "  • Missing essential configuration"
    echo "  • Binary corruption detection"
    echo
}

check_dependencies() {
    if [[ ! -d "$LOCATIONS_DIR" ]]; then
        echo -e "${RED}Error: Locations directory not found: $LOCATIONS_DIR${NC}"
        return 1
    fi

    local ovpn_count
    ovpn_count=$(find "$LOCATIONS_DIR" -name "*.ovpn" 2>/dev/null | wc -l)

    if [[ $ovpn_count -eq 0 ]]; then
        echo -e "${YELLOW}No .ovpn files found in $LOCATIONS_DIR${NC}"
        return 1
    fi

    echo -e "${GREEN}Found $ovpn_count .ovpn files to process${NC}"
    return 0
}

is_binary_file() {
    local file="$1"

    # Check for OpenVPN-specific corruption patterns
    # Look for specific characters that indicate corruption
    if grep -q "ÿ\|ø\|§" "$file" 2>/dev/null; then
        return 0  # Is corrupted/binary
    fi

    # Check for null bytes
    if grep -qz $'\0' "$file" 2>/dev/null; then
        return 0  # Contains null bytes
    fi

    return 1  # Not binary
}

validate_ovpn_config() {
    local ovpn_file="$1"
    local issues=""

    # Debug output - remove this later
    # echo "DEBUG: Validating $ovpn_file" >&2

    # Check if file exists and is readable
    if [[ ! -r "$ovpn_file" ]]; then
        echo "UNREADABLE"
        return 1
    fi

    # Check if file is binary/corrupted - look for specific corruption patterns
    if grep -q "ÿ\|ø\|§" "$ovpn_file" 2>/dev/null; then
        echo "BINARY_CORRUPTION"
        return 1
    fi

    # SECURITY: Check for potentially malicious content
    if grep -qE "(exec|system|\`|\\\$\\\(|\.\.\\/|~\\/|;|&|\\\|)" "$ovpn_file" 2>/dev/null; then
        echo "SUSPICIOUS_CONTENT"
        return 1
    fi

    # SECURITY: Validate reasonable file size (prevent resource exhaustion)
    local file_size
    file_size=$(stat -c%s "$ovpn_file" 2>/dev/null || echo "0")
    if [[ $file_size -gt 1048576 ]]; then  # 1MB limit
        echo "FILE_TOO_LARGE"
        return 1
    fi

    # Check for essential directives
    if ! grep -q "^client" "$ovpn_file" 2>/dev/null; then
        issues="${issues}MISSING_CLIENT "
    fi

    if ! grep -q "^remote.*[0-9]" "$ovpn_file" 2>/dev/null; then
        if grep -q "^remote[[:space:]]*$" "$ovpn_file" 2>/dev/null; then
            issues="${issues}MALFORMED_REMOTE "
        else
            issues="${issues}MISSING_REMOTE "
        fi
    fi

    # Check for at least some basic configuration
    if ! grep -qE "^(dev|proto|cipher|auth)" "$ovpn_file" 2>/dev/null; then
        issues="${issues}INCOMPLETE_CONFIG "
    fi

    if [[ -n "$issues" ]]; then
        echo "${issues% }"  # Remove trailing space
        return 1
    fi

    echo "VALID"
    return 0
}

can_repair() {
    local issues="$1"

    # Security issues cannot be repaired
    if [[ "$issues" =~ BINARY_CORRUPTION|SUSPICIOUS_CONTENT|FILE_TOO_LARGE|UNREADABLE ]]; then
        return 1
    fi

    # Some specific issues can be repaired
    if [[ "$issues" =~ MISSING_CLIENT|MALFORMED_REMOTE ]]; then
        return 0
    fi

    # Incomplete config might be repairable depending on what's missing
    return 1
}

create_backup() {
    local ovpn_file="$1"

    # SECURITY: Create backup directory with restrictive permissions
    if ! mkdir -p "$BACKUP_DIR" || ! chmod 700 "$BACKUP_DIR"; then
        echo -e "${RED}Error: Failed to create secure backup directory${NC}"
        return 1
    fi

    local backup_file="$BACKUP_DIR/$(basename "$ovpn_file").backup.$(date +%Y%m%d_%H%M%S)"

    if cp "$ovpn_file" "$backup_file"; then
        # SECURITY: Set restrictive permissions on backup file
        chmod 600 "$backup_file"
        echo "  Backup created: $backup_file"
        return 0
    else
        echo -e "${RED}Error: Failed to create backup for $(basename "$ovpn_file")${NC}"
        return 1
    fi
}

repair_ovpn_file() {
    local ovpn_file="$1"
    local issues="$2"
    local create_backup_flag="$3"

    echo -e "${BLUE}Repairing: $(basename "$ovpn_file")${NC}"

    # Create backup if requested
    if [[ "$create_backup_flag" == "true" ]]; then
        if ! create_backup "$ovpn_file"; then
            return 1
        fi
    fi

    # SECURITY: Create temporary file with secure permissions
    local temp_file
    temp_file=$(mktemp) || {
        echo -e "${RED}Error: Failed to create secure temporary file${NC}"
        return 1
    }

    # SECURITY: Set restrictive permissions immediately
    chmod 600 "$temp_file" || {
        rm -f "$temp_file"
        echo -e "${RED}Error: Failed to secure temporary file${NC}"
        return 1
    }

    # SECURITY: Ensure cleanup on exit
    trap 'rm -f "$temp_file"' EXIT

    # Copy original content
    cp "$ovpn_file" "$temp_file"

    # Apply repairs based on detected issues
    if [[ "$issues" =~ MISSING_CLIENT ]]; then
        # Add client directive at the beginning
        sed -i '1i\client' "$temp_file"
        echo "  Added: client directive"
    fi

    if [[ "$issues" =~ MALFORMED_REMOTE ]]; then
        # Try to fix malformed remote lines by removing empty ones
        sed -i '/^remote\s*$/d' "$temp_file"
        echo "  Removed: malformed remote directive"
    fi

    # Replace original file with repaired version
    if mv "$temp_file" "$ovpn_file"; then
        echo -e "${GREEN}  ✓ REPAIRED: $(basename "$ovpn_file")${NC}"
        return 0
    else
        echo -e "${RED}  ✗ FAILED to repair: $(basename "$ovpn_file")${NC}"
        rm -f "$temp_file"
        return 1
    fi
}

check_files() {
    echo -e "${BLUE}Checking .ovpn files for corruption and issues...${NC}"
    echo

    local files_valid=0
    local files_repairable=0
    local files_unrepairable=0

    while IFS= read -r -d '' ovpn_file; do
        local issues
        issues=$(validate_ovpn_config "$ovpn_file") || true

        if [[ "$issues" == "VALID" ]]; then
            echo -e "${GREEN}VALID:${NC} $(basename "$ovpn_file")"
            files_valid=$((files_valid + 1))
        elif can_repair "$issues"; then
            echo -e "${YELLOW}REPAIRABLE:${NC} $(basename "$ovpn_file") ($issues)"
            files_repairable=$((files_repairable + 1))
        else
            echo -e "${RED}UNREPAIRABLE:${NC} $(basename "$ovpn_file") ($issues)"
            files_unrepairable=$((files_unrepairable + 1))
        fi
    done < <(find "$LOCATIONS_DIR" -name "*.ovpn" -print0)

    echo
    echo -e "${BLUE}Check Summary:${NC}"
    echo -e "  Valid files: ${GREEN}$files_valid${NC}"
    echo -e "  Repairable files: ${YELLOW}$files_repairable${NC}"
    echo -e "  Unrepairable files: ${RED}$files_unrepairable${NC}"
}

repair_all_files() {
    local create_backup_flag="$1"

    echo -e "${BLUE}Repairing all correctable .ovpn files...${NC}"
    echo

    local repaired_count=0
    local error_count=0
    local skipped_count=0

    while IFS= read -r -d '' ovpn_file; do
        local issues
        issues=$(validate_ovpn_config "$ovpn_file") || true

        if [[ "$issues" == "VALID" ]]; then
            echo -e "${GREEN}SKIP: $(basename "$ovpn_file") (already valid)${NC}"
            skipped_count=$((skipped_count + 1))
        elif can_repair "$issues"; then
            if repair_ovpn_file "$ovpn_file" "$issues" "$create_backup_flag"; then
                repaired_count=$((repaired_count + 1))
            else
                error_count=$((error_count + 1))
            fi
        else
            echo -e "${RED}UNREPAIRABLE: $(basename "$ovpn_file") ($issues)${NC}"
            error_count=$((error_count + 1))
        fi
        echo
    done < <(find "$LOCATIONS_DIR" -name "*.ovpn" -print0)

    echo -e "${BLUE}Repair Summary:${NC}"
    echo -e "  Files repaired: ${GREEN}$repaired_count${NC}"
    echo -e "  Files skipped: ${YELLOW}$skipped_count${NC}"
    echo -e "  Errors/Unrepairable: ${RED}$error_count${NC}"

    if [[ $error_count -eq 0 ]]; then
        echo -e "${GREEN}✓ All repairable files fixed successfully!${NC}"
        return 0
    else
        echo -e "${YELLOW}⚠ Some files could not be repaired. Check output above.${NC}"
        return 1
    fi
}

main() {
    local check_only=false
    local repair_mode=false
    local create_backup=true

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --check)
                check_only=true
                shift
                ;;
            --repair)
                repair_mode=true
                shift
                ;;
            --backup)
                create_backup=true
                shift
                ;;
            --no-backup)
                create_backup=false
                shift
                ;;
            --directory)
                # SECURITY: Validate and canonicalize directory path
                local requested_dir="$2"
                if [[ -z "$requested_dir" ]]; then
                    echo -e "${RED}Error: --directory requires a path${NC}"
                    exit 1
                fi

                # Resolve canonical path and validate it exists
                LOCATIONS_DIR="$(realpath "$requested_dir" 2>/dev/null)" || {
                    echo -e "${RED}Error: Directory validation failed${NC}"
                    exit 1
                }

                # SECURITY: Ensure directory is within project scope to prevent traversal attacks
                local project_real="$(realpath "$PROJECT_ROOT" 2>/dev/null)"
                if [[ ! "$LOCATIONS_DIR" =~ ^"$project_real" ]]; then
                    echo -e "${RED}Error: Directory must be within project scope${NC}"
                    exit 1
                fi

                shift 2
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                show_help
                exit 1
                ;;
        esac
    done

    print_banner

    if ! check_dependencies; then
        exit 1
    fi

    echo

    if [[ "$check_only" == "true" ]]; then
        check_files
    elif [[ "$repair_mode" == "true" ]]; then
        repair_all_files "$create_backup"
    else
        # Default behavior: check first
        check_files
    fi
}

# Only run if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
