#!/bin/bash
# ABOUTME: Secure credential manager with GPG encryption for ProtonVPN Config Downloader
# ABOUTME: Handles ProtonVPN account credentials, OpenVPN credentials, and TOTP secrets

set -euo pipefail

# Configuration
readonly SCRIPT_NAME="$(basename "$0")"
readonly CACHE_DIR="${HOME}/.cache/vpn"
readonly CREDENTIALS_DIR="${CACHE_DIR}/credentials"
readonly BACKUP_DIR="${CACHE_DIR}/migration-backup"

# Security settings
readonly GPG_KEY_TYPE="RSA"
readonly GPG_KEY_LENGTH="4096"
readonly GPG_EXPIRE="2y"
readonly FILE_PERMISSIONS="600"

# Logging
log_message() {
	local level="$1"
	local message="$2"
	echo "[$level] $(date '+%Y-%m-%d %H:%M:%S') $message"
}

# Initialize secure storage environment
init_secure_storage() {
	log_message "INFO" "Initializing secure credential storage"

	# Create directories with proper permissions
	mkdir -p "$CREDENTIALS_DIR" "$BACKUP_DIR"
	chmod 700 "$CACHE_DIR" "$CREDENTIALS_DIR" "$BACKUP_DIR"

	# Check for existing GPG setup
	if ! gpg --list-secret-keys 2>/dev/null | grep -q "vpn-manager@"; then
		log_message "INFO" "Setting up VPN Manager GPG key"
		if ! setup_gpg_key; then
			log_message "WARN" "GPG key generation failed, but storage directories created"
			log_message "INFO" "You may need to generate a GPG key manually"
			return 0 # Don't fail init just because of GPG key issues
		fi
	fi

	log_message "INFO" "Secure storage initialized successfully"
}

# Setup GPG key for encryption
setup_gpg_key() {
	local key_params_file="/tmp/vpn_key_params_$$"

	cat >"$key_params_file" <<EOF
Key-Type: RSA
Key-Length: 2048
Name-Real: VPN Manager
Name-Email: vpn-manager@localhost
Expire-Date: 2y
Passphrase:
%commit
EOF

	log_message "INFO" "Generating GPG key (this may take a moment)..."

	# Use faster key generation for testing/development
	export GNUPG_ALLOW_FREEFORM_UID=1
	if gpg --batch --generate-key "$key_params_file" 2>/dev/null; then
		log_message "INFO" "GPG key generated successfully"
		rm -f "$key_params_file"
		return 0
	else
		log_message "ERROR" "Failed to generate GPG key"
		rm -f "$key_params_file"
		return 1
	fi
}

# Get GPG key ID for VPN Manager
get_vpn_gpg_key() {
	local key_id
	key_id=$(gpg --list-secret-keys --with-colons 2>/dev/null |
		grep -A1 "vpn-manager@localhost" |
		grep "^sec" |
		cut -d: -f5)

	# If no VPN manager key, try to use any available key for testing
	if [[ -z "$key_id" ]]; then
		key_id=$(gpg --list-secret-keys --with-colons 2>/dev/null |
			grep "^sec" | head -1 | cut -d: -f5)
	fi

	echo "$key_id"
}

# Encrypt and store ProtonVPN account credentials
store_protonvpn() {
	local username="$1"
	local password="$2"

	log_message "INFO" "Storing ProtonVPN account credentials securely"

	init_secure_storage

	local key_id
	key_id=$(get_vpn_gpg_key)
	if [[ -z "$key_id" ]]; then
		log_message "ERROR" "No VPN Manager GPG key found"
		return 1
	fi

	# Validate input
	if [[ -z "$username" || -z "$password" ]]; then
		log_message "ERROR" "Username and password are required"
		return 1
	fi

	# Sanitize input (basic validation)
	if [[ "$username" =~ [[:space:]] || "$password" =~ [[:space:]] ]]; then
		log_message "ERROR" "Credentials cannot contain spaces"
		return 1
	fi

	# Create credentials file
	local creds_file="${CREDENTIALS_DIR}/proton-account.gpg"
	local temp_file="/tmp/vpn_creds_$$"

	# Write credentials to temp file
	cat >"$temp_file" <<EOF
username=$username
password=$password
created=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
EOF

	# Encrypt and store
	if gpg --trust-model always --encrypt --recipient "$key_id" \
		--output "$creds_file" "$temp_file" 2>/dev/null; then
		log_message "INFO" "ProtonVPN credentials stored successfully"
		chmod "$FILE_PERMISSIONS" "$creds_file"
	else
		log_message "ERROR" "Failed to encrypt ProtonVPN credentials"
		rm -f "$temp_file"
		return 1
	fi

	# Secure cleanup
	shred -u "$temp_file" 2>/dev/null || rm -f "$temp_file"

	return 0
}

# Store TOTP secret with Base32 validation
store_totp() {
	local totp_secret="$1"

	log_message "INFO" "Storing TOTP secret securely"

	# Validate Base32 format (RFC 4648)
	if ! validate_totp "$totp_secret"; then
		log_message "ERROR" "Invalid TOTP secret format (must be Base32)"
		return 1
	fi

	init_secure_storage

	local key_id
	key_id=$(get_vpn_gpg_key)
	if [[ -z "$key_id" ]]; then
		log_message "ERROR" "No VPN Manager GPG key found"
		return 1
	fi

	# Create TOTP file
	local totp_file="${CREDENTIALS_DIR}/totp-secret.gpg"
	local temp_file="/tmp/vpn_totp_$$"

	# Write TOTP secret to temp file
	cat >"$temp_file" <<EOF
totp_secret=$totp_secret
created=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
EOF

	# Encrypt and store
	if gpg --trust-model always --encrypt --recipient "$key_id" \
		--output "$totp_file" "$temp_file" 2>/dev/null; then
		log_message "INFO" "TOTP secret stored successfully"
		chmod "$FILE_PERMISSIONS" "$totp_file"
	else
		log_message "ERROR" "Failed to encrypt TOTP secret"
		rm -f "$temp_file"
		return 1
	fi

	# Secure cleanup
	shred -u "$temp_file" 2>/dev/null || rm -f "$temp_file"

	return 0
}

# Retrieve ProtonVPN credentials
get_protonvpn() {
	local creds_file="${CREDENTIALS_DIR}/proton-account.gpg"

	if [[ ! -f "$creds_file" ]]; then
		log_message "ERROR" "ProtonVPN credentials not found"
		return 1
	fi

	local temp_file="/tmp/vpn_retrieve_$$"

	# Decrypt credentials
	if gpg --quiet --decrypt --output "$temp_file" "$creds_file" 2>/dev/null; then
		# Source the credentials (safe since we control the format)
		# shellcheck source=/dev/null
		source "$temp_file"
		echo "USERNAME=$username"
		echo "PASSWORD=$password"

		# Secure cleanup
		shred -u "$temp_file" 2>/dev/null || rm -f "$temp_file"
		return 0
	else
		log_message "ERROR" "Failed to decrypt ProtonVPN credentials"
		rm -f "$temp_file"
		return 1
	fi
}

# Retrieve TOTP secret
get_totp() {
	local totp_file="${CREDENTIALS_DIR}/totp-secret.gpg"

	if [[ ! -f "$totp_file" ]]; then
		log_message "ERROR" "TOTP secret not found"
		return 1
	fi

	local temp_file="/tmp/vpn_totp_retrieve_$$"

	# Decrypt TOTP secret
	if gpg --quiet --decrypt --output "$temp_file" "$totp_file" 2>/dev/null; then
		# Source the TOTP data (safe since we control the format)
		# shellcheck source=/dev/null
		source "$temp_file"
		echo "TOTP_SECRET=$totp_secret"

		# Secure cleanup
		shred -u "$temp_file" 2>/dev/null || rm -f "$temp_file"
		return 0
	else
		log_message "ERROR" "Failed to decrypt TOTP secret"
		rm -f "$temp_file"
		return 1
	fi
}

# Validate TOTP secret format (Base32 RFC 4648)
validate_totp() {
	local secret="$1"

	# Check Base32 format: A-Z, 2-7, optional padding with =
	if [[ "$secret" =~ ^[A-Z2-7]+(=*)$ ]] && [[ ${#secret} -ge 16 ]]; then
		return 0
	else
		return 1
	fi
}

# Security check for credential storage
security_check() {
	log_message "INFO" "Performing security check on credential storage"

	local errors=0

	# Check directory permissions
	if [[ ! -d "$CREDENTIALS_DIR" ]]; then
		log_message "ERROR" "Credentials directory does not exist"
		((errors++))
	else
		local dir_perms
		dir_perms=$(stat -c "%a" "$CREDENTIALS_DIR")
		if [[ "$dir_perms" != "700" ]]; then
			log_message "ERROR" "Credentials directory has incorrect permissions: $dir_perms (should be 700)"
			((errors++))
		fi
	fi

	# Check GPG key availability
	if ! get_vpn_gpg_key >/dev/null 2>&1; then
		log_message "ERROR" "VPN Manager GPG key not found"
		((errors++))
	fi

	# Check credential file permissions
	for cred_file in "$CREDENTIALS_DIR"/*.gpg; do
		if [[ -f "$cred_file" ]]; then
			local file_perms
			file_perms=$(stat -c "%a" "$cred_file")
			if [[ "$file_perms" != "600" ]]; then
				log_message "ERROR" "Credential file has incorrect permissions: $file_perms (should be 600)"
				((errors++))
			fi
		fi
	done

	if [[ $errors -eq 0 ]]; then
		log_message "INFO" "Security check passed"
		return 0
	else
		log_message "ERROR" "Security check failed with $errors errors"
		return 1
	fi
}

# Create secure backup
create_backup() {
	log_message "INFO" "Creating secure backup of credentials"

	if [[ ! -d "$CREDENTIALS_DIR" ]]; then
		log_message "ERROR" "No credentials to backup"
		return 1
	fi

	local backup_timestamp
	backup_timestamp=$(date -u '+%Y%m%d_%H%M%S')
	local backup_file="${BACKUP_DIR}/credentials_backup_${backup_timestamp}.tar.gz.gpg"

	local key_id
	key_id=$(get_vpn_gpg_key)
	if [[ -z "$key_id" ]]; then
		log_message "ERROR" "No VPN Manager GPG key found for backup"
		return 1
	fi

	# Create encrypted backup
	local temp_tar="/tmp/vpn_backup_$$.tar.gz"

	if tar -czf "$temp_tar" -C "$CACHE_DIR" credentials 2>/dev/null; then
		if gpg --trust-model always --encrypt --recipient "$key_id" \
			--output "$backup_file" "$temp_tar" 2>/dev/null; then
			log_message "INFO" "Backup created successfully: $backup_file"
			chmod "$FILE_PERMISSIONS" "$backup_file"
		else
			log_message "ERROR" "Failed to encrypt backup"
			rm -f "$temp_tar"
			return 1
		fi
	else
		log_message "ERROR" "Failed to create backup archive"
		return 1
	fi

	# Secure cleanup
	shred -u "$temp_tar" 2>/dev/null || rm -f "$temp_tar"

	return 0
}

# Display usage information
show_usage() {
	cat <<EOF
Usage: $SCRIPT_NAME <command> [arguments]

Commands:
    store-protonvpn <username> <password>  Store ProtonVPN account credentials
    store-totp <secret>                    Store TOTP secret (Base32 format)
    get-protonvpn                          Retrieve ProtonVPN credentials
    get-totp                               Retrieve TOTP secret
    validate-totp <secret>                 Validate TOTP secret format
    security-check                         Perform security validation
    create-backup                          Create encrypted backup
    init                                   Initialize secure storage

Examples:
    $SCRIPT_NAME store-protonvpn myuser mypassword
    $SCRIPT_NAME store-totp JBSWY3DPEHPK3PXP
    $SCRIPT_NAME get-protonvpn
    $SCRIPT_NAME security-check

EOF
}

# Main command handler
main() {
	local command="${1:-}"

	case "$command" in
	"store-protonvpn")
		if [[ $# -ne 3 ]]; then
			log_message "ERROR" "Usage: $SCRIPT_NAME store-protonvpn <username> <password>"
			return 1
		fi
		store_protonvpn "$2" "$3"
		;;
	"store-totp")
		if [[ $# -ne 2 ]]; then
			log_message "ERROR" "Usage: $SCRIPT_NAME store-totp <secret>"
			return 1
		fi
		store_totp "$2"
		;;
	"get-protonvpn")
		get_protonvpn
		;;
	"get-totp")
		get_totp
		;;
	"validate-totp")
		if [[ $# -ne 2 ]]; then
			log_message "ERROR" "Usage: $SCRIPT_NAME validate-totp <secret>"
			return 1
		fi
		if validate_totp "$2"; then
			log_message "INFO" "TOTP secret format is valid"
			return 0
		else
			log_message "ERROR" "TOTP secret format is invalid"
			return 1
		fi
		;;
	"security-check")
		security_check
		;;
	"create-backup")
		create_backup
		;;
	"init")
		init_secure_storage
		;;
	"help" | "--help" | "-h")
		show_usage
		;;
	"")
		log_message "ERROR" "No command specified"
		show_usage
		return 1
		;;
	*)
		log_message "ERROR" "Unknown command: $command"
		show_usage
		return 1
		;;
	esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
