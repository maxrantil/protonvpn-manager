#!/bin/bash
# ABOUTME: Secure credential manager with GPG encryption for ProtonVPN Config Downloader
# ABOUTME: Handles ProtonVPN account credentials, OpenVPN credentials, and TOTP secrets

set -euo pipefail

# Configuration
readonly SCRIPT_NAME="$(basename "$0")"
readonly CACHE_DIR="${HOME}/.cache/vpn"
readonly CREDENTIALS_DIR="${CACHE_DIR}/credentials"
readonly BACKUP_DIR="${CACHE_DIR}/migration-backup"

# Security settings
readonly GPG_KEY_TYPE="RSA"
readonly GPG_KEY_LENGTH="4096"
readonly GPG_EXPIRE="2y"
readonly FILE_PERMISSIONS="600"

# Logging
log_message() {
    local level="$1"
    local message="$2"
    echo "[$level] $(date '+%Y-%m-%d %H:%M:%S') $message";
}

# Initialize secure storage environment
init_secure_storage() {
    log_message "INFO" "Initializing secure credential storage"

    # Create directories with proper permissions
    mkdir -p "$CREDENTIALS_DIR" "$BACKUP_DIR"
    chmod 700 "$CACHE_DIR" "$CREDENTIALS_DIR" "$BACKUP_DIR"

    # Check for existing GPG setup
    if ! gpg --list-secret-keys 2>/dev/null | grep -q "vpn-manager@"; then
        log_message "INFO" "Setting up VPN Manager GPG key"
        if ! setup_gpg_key; then
            log_message "WARN" "GPG key generation failed, but storage directories created"
            log_message "INFO" "You may need to generate a GPG key manually"
            return 0  # Don't fail init just because of GPG key issues
        fi
    fi

    log_message "INFO" "Secure storage initialized successfully"
}

# Setup GPG key for encryption
setup_gpg_key() {
    local key_params_file="/tmp/vpn_key_params_$$"

    cat > "$key_params_file" << EOF
Key-Type: RSA
Key-Length: 2048
Name-Real: VPN Manager
Name-Email: vpn-manager@localhost
Expire-Date: 2y
Passphrase:
%commit
EOF

    log_message "INFO" "Generating GPG key (this may take a moment)..."

    # Use faster key generation for testing/development
    export GNUPG_ALLOW_FREEFORM_UID=1
    if gpg --batch --generate-key "$key_params_file" 2>/dev/null; then
        log_message "INFO" "GPG key generated successfully"
        rm -f "$key_params_file"
        return 0
    else
        log_message "ERROR" "Failed to generate GPG key"
        rm -f "$key_params_file"
        return 1
    fi
}

# Get GPG key ID for VPN Manager
get_vpn_gpg_key() {
    local key_id
    key_id=$(gpg --list-secret-keys --with-colons 2>/dev/null | \
        grep -A1 "vpn-manager@localhost" | \
        grep "^sec" | \
        cut -d: -f5)

    # If no VPN manager key, try to use any available key for testing
    if [[ -z "$key_id" ]]; then
        key_id=$(gpg --list-secret-keys --with-colons 2>/dev/null | \
            grep "^sec" | head -1 | cut -d: -f5)
    fi

    echo "$key_id"
}

# Encrypt and store ProtonVPN account credentials
store_protonvpn() {
    local username="$1"
    local password="$2"

    log_message "INFO" "Storing ProtonVPN account credentials securely"

    init_secure_storage

    local key_id
    key_id=$(get_vpn_gpg_key)
    if [[ -z "$key_id" ]]; then
        log_message "ERROR" "No VPN Manager GPG key found"
        return 1
    fi

    # Validate input
    if [[ -z "$username" || -z "$password" ]]; then
        log_message "ERROR" "Username and password are required"
        return 1
    fi

    # Sanitize input (basic validation)
    if [[ "$username" =~ [[:space:]] || "$password" =~ [[:space:]] ]]; then
        log_message "ERROR" "Credentials cannot contain spaces"
        return 1
    fi

    # Create credentials file
    local creds_file="${CREDENTIALS_DIR}/proton-account.gpg"
    local temp_file="/tmp/vpn_creds_$$"

    # Write credentials to temp file
    cat > "$temp_file" << EOF
username=$username
password=$password
created=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
EOF

    # Encrypt and store
    if gpg --trust-model always --encrypt --recipient "$key_id" \
           --output "$creds_file" "$temp_file" 2>/dev/null; then
        log_message "INFO" "ProtonVPN credentials stored successfully"
        chmod "$FILE_PERMISSIONS" "$creds_file"
    else
        log_message "ERROR" "Failed to encrypt ProtonVPN credentials"
        rm -f "$temp_file"
        return 1
    fi

    # Secure cleanup
    shred -u "$temp_file" 2>/dev/null || rm -f "$temp_file"

    return 0
}

# Store TOTP secret with Base32 validation
store_totp() {
    local totp_secret="$1"

    log_message "INFO" "Storing TOTP secret securely"

    # Validate Base32 format (RFC 4648)
    if ! validate_totp "$totp_secret"; then
        log_message "ERROR" "Invalid TOTP secret format (must be Base32)"
        return 1
    fi

    init_secure_storage

    local key_id
    key_id=$(get_vpn_gpg_key)
    if [[ -z "$key_id" ]]; then
        log_message "ERROR" "No VPN Manager GPG key found"
        return 1
    fi

    # Create TOTP file
    local totp_file="${CREDENTIALS_DIR}/totp-secret.gpg"
    local temp_file="/tmp/vpn_totp_$$"

    # Write TOTP secret to temp file
    cat > "$temp_file" << EOF
totp_secret=$totp_secret
created=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
EOF

    # Encrypt and store
    if gpg --trust-model always --encrypt --recipient "$key_id" \
           --output "$totp_file" "$temp_file" 2>/dev/null; then
        log_message "INFO" "TOTP secret stored successfully"
        chmod "$FILE_PERMISSIONS" "$totp_file"
    else
        log_message "ERROR" "Failed to encrypt TOTP secret"
        rm -f "$temp_file"
        return 1
    fi

    # Secure cleanup
    shred -u "$temp_file" 2>/dev/null || rm -f "$temp_file"

    return 0
}

# Retrieve ProtonVPN credentials
get_protonvpn() {
    local creds_file="${CREDENTIALS_DIR}/proton-account.gpg"

    if [[ ! -f "$creds_file" ]]; then
        log_message "ERROR" "ProtonVPN credentials not found"
        return 1
    fi

    local temp_file="/tmp/vpn_retrieve_$$"

    # Decrypt credentials
    if gpg --quiet --decrypt --output "$temp_file" "$creds_file" 2>/dev/null; then
        # Source the credentials (safe since we control the format)
        # shellcheck source=/dev/null
        source "$temp_file"
        echo "USERNAME=$username"
        echo "PASSWORD=$password"

        # Secure cleanup
        shred -u "$temp_file" 2>/dev/null || rm -f "$temp_file"
        return 0
    else
        log_message "ERROR" "Failed to decrypt ProtonVPN credentials"
        rm -f "$temp_file"
        return 1
    fi
}

# Retrieve TOTP secret
get_totp() {
    local totp_file="${CREDENTIALS_DIR}/totp-secret.gpg"

    if [[ ! -f "$totp_file" ]]; then
        log_message "ERROR" "TOTP secret not found"
        return 1
    fi

    local temp_file="/tmp/vpn_totp_retrieve_$$"

    # Decrypt TOTP secret
    if gpg --quiet --decrypt --output "$temp_file" "$totp_file" 2>/dev/null; then
        # Source the TOTP data (safe since we control the format)
        # shellcheck source=/dev/null
        source "$temp_file"
        echo "TOTP_SECRET=$totp_secret"

        # Secure cleanup
        shred -u "$temp_file" 2>/dev/null || rm -f "$temp_file"
        return 0
    else
        log_message "ERROR" "Failed to decrypt TOTP secret"
        rm -f "$temp_file"
        return 1
    fi
}

# Validate TOTP secret format (Base32 RFC 4648)
validate_totp() {
    local secret="$1"

    # Check Base32 format: A-Z, 2-7, optional padding with =
    if [[ "$secret" =~ ^[A-Z2-7]+(=*)$ ]] && [[ ${#secret} -ge 16 ]]; then
        return 0
    else
        return 1
    fi
}

# Security check for credential storage
security_check() {
    log_message "INFO" "Performing security check on credential storage"

    local errors=0

    # Check directory permissions
    if [[ ! -d "$CREDENTIALS_DIR" ]]; then
        log_message "ERROR" "Credentials directory does not exist"
        ((errors++))
    else
        local dir_perms
        dir_perms=$(stat -c "%a" "$CREDENTIALS_DIR")
        if [[ "$dir_perms" != "700" ]]; then
            log_message "ERROR" "Credentials directory has incorrect permissions: $dir_perms (should be 700)"
            ((errors++))
        fi
    fi

    # Check GPG key availability
    if ! get_vpn_gpg_key >/dev/null 2>&1; then
        log_message "ERROR" "VPN Manager GPG key not found"
        ((errors++))
    fi

    # Check credential file permissions
    for cred_file in "$CREDENTIALS_DIR"/*.gpg; do
        if [[ -f "$cred_file" ]]; then
            local file_perms
            file_perms=$(stat -c "%a" "$cred_file")
            if [[ "$file_perms" != "600" ]]; then
                log_message "ERROR" "Credential file has incorrect permissions: $file_perms (should be 600)"
                ((errors++))
            fi
        fi
    done

    if [[ $errors -eq 0 ]]; then
        log_message "INFO" "Security check passed"
        return 0
    else
        log_message "ERROR" "Security check failed with $errors errors"
        return 1
    fi
}

# Create secure backup
create_backup() {
    log_message "INFO" "Creating secure backup of credentials"

    if [[ ! -d "$CREDENTIALS_DIR" ]]; then
        log_message "ERROR" "No credentials to backup"
        return 1
    fi

    local backup_timestamp
    backup_timestamp=$(date -u '+%Y%m%d_%H%M%S')
    local backup_file="${BACKUP_DIR}/credentials_backup_${backup_timestamp}.tar.gz.gpg"

    local key_id
    key_id=$(get_vpn_gpg_key)
    if [[ -z "$key_id" ]]; then
        log_message "ERROR" "No VPN Manager GPG key found for backup"
        return 1
    fi

    # Create encrypted backup
    local temp_tar="/tmp/vpn_backup_$$.tar.gz"

    if tar -czf "$temp_tar" -C "$CACHE_DIR" credentials 2>/dev/null; then
        if gpg --trust-model always --encrypt --recipient "$key_id" \
               --output "$backup_file" "$temp_tar" 2>/dev/null; then
            log_message "INFO" "Backup created successfully: $backup_file"
            chmod "$FILE_PERMISSIONS" "$backup_file"
        else
            log_message "ERROR" "Failed to encrypt backup"
            rm -f "$temp_tar"
            return 1
        fi
    else
        log_message "ERROR" "Failed to create backup archive"
        return 1
    fi

    # Secure cleanup
    shred -u "$temp_tar" 2>/dev/null || rm -f "$temp_tar"

    return 0
}

# Display usage information
show_usage() {
    cat << EOF
Usage: $SCRIPT_NAME <command> [arguments]

Commands:
    store-protonvpn <username> <password>  Store ProtonVPN account credentials
    store-totp <secret>                    Store TOTP secret (Base32 format)
    get-protonvpn                          Retrieve ProtonVPN credentials
    get-totp                               Retrieve TOTP secret
    validate-totp <secret>                 Validate TOTP secret format
    security-check                         Perform security validation
    create-backup                          Create encrypted backup
    init                                   Initialize secure storage

Examples:
    $SCRIPT_NAME store-protonvpn myuser mypassword
    $SCRIPT_NAME store-totp JBSWY3DPEHPK3PXP
    $SCRIPT_NAME get-protonvpn
    $SCRIPT_NAME security-check

EOF
}

# Main command handler
main() {
    local command="${1:-}"

    case "$command" in
        "store-protonvpn")
            if [[ $# -ne 3 ]]; then
                log_message "ERROR" "Usage: $SCRIPT_NAME store-protonvpn <username> <password>"
                return 1
            fi
            store_protonvpn "$2" "$3"
            ;;
        "store-totp")
            if [[ $# -ne 2 ]]; then
                log_message "ERROR" "Usage: $SCRIPT_NAME store-totp <secret>"
                return 1
            fi
            store_totp "$2"
            ;;
        "get-protonvpn")
            get_protonvpn
            ;;
        "get-totp")
            get_totp
            ;;
        "validate-totp")
            if [[ $# -ne 2 ]]; then
                log_message "ERROR" "Usage: $SCRIPT_NAME validate-totp <secret>"
                return 1
            fi
            if validate_totp "$2"; then
                log_message "INFO" "TOTP secret format is valid"
                return 0
            else
                log_message "ERROR" "TOTP secret format is invalid"
                return 1
            fi
            ;;
        "security-check")
            security_check
            ;;
        "create-backup")
            create_backup
            ;;
        "init")
            init_secure_storage
            ;;
        "help"|"--help"|"-h")
            show_usage
            ;;
        "")
            log_message "ERROR" "No command specified"
            show_usage
            return 1
            ;;
        *)
            log_message "ERROR" "Unknown command: $command"
            show_usage
            return 1
            ;;
    esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
