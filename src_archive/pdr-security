#!/bin/bash
# ABOUTME: Security validation and sanitization library for PDR system
# ABOUTME: Provides path traversal prevention, input sanitization, and secure file operations

# Source existing error handling
VPN_DIR="$(dirname "$(realpath "$0")")"
if [[ -f "$VPN_DIR/vpn-error-handler" ]]; then
	source "$VPN_DIR/vpn-error-handler"
else
	# Fallback error function for testing
	vpn_error() {
		echo "[$1] $2: $3 - $4" >&2
		return 1
	}
fi

# PDR-specific security constants (with guards to prevent redefinition)
if [[ -z "$PDR_COMPONENT" ]]; then
	readonly PDR_COMPONENT="PDR-SECURITY"
	readonly ERR_SECURITY="SECURITY"
	readonly ERR_INPUT="INPUT_VALIDATION"
fi

# PDR security error templates
declare -A PDR_ERROR_TEMPLATES=(
	["PATH_TRAVERSAL"]="Path traversal attempt detected"
	["SHELL_INJECTION"]="Shell injection attempt blocked"
	["INPUT_TOO_LARGE"]="Input exceeds maximum allowed size"
	["INVALID_CHARACTERS"]="Input contains invalid or dangerous characters"
	["RACE_CONDITION"]="File operation race condition detected"
	["PERMISSION_VIOLATION"]="File permission validation failed"
)

# PDR security actions
declare -A PDR_SECURITY_ACTIONS=(
	["PATH_TRAVERSAL"]="Use only alphanumeric characters, hyphens, and underscores in PDR names"
	["SHELL_INJECTION"]="Avoid shell metacharacters in PDR content and names"
	["INPUT_TOO_LARGE"]="Reduce content size to under 10MB limit"
	["INVALID_CHARACTERS"]="Use standard ASCII characters only"
	["RACE_CONDITION"]="Wait for current PDR operation to complete before starting new one"
	["PERMISSION_VIOLATION"]="Check file permissions and ownership in PDR directory"
)

# Critical security settings (with guards)
if [[ -z "$PDR_MAX_SIZE" ]]; then
	readonly PDR_MAX_SIZE=10485760 # 10MB limit
	readonly PDR_MAX_NAME_LENGTH=50
	readonly PDR_NAME_PATTERN='^[a-zA-Z0-9][a-zA-Z0-9_-]{0,49}$'
fi

# Secure PDR directory validation
validate_pdr_directory() {
	local pdr_dir="${1:-$PROJECT_ROOT/docs/pdr}"

	# Resolve to canonical path
	local canonical_dir
	canonical_dir=$(realpath "$pdr_dir" 2>/dev/null) || {
		vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"${PDR_ERROR_TEMPLATES[PERMISSION_VIOLATION]}" \
			"Cannot resolve PDR directory: $pdr_dir" \
			"Ensure PDR directory exists and is accessible"
		return 1
	}

	# Ensure directory is within project bounds
	local project_root
	project_root=$(realpath "$PROJECT_ROOT" 2>/dev/null) || {
		vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"Cannot resolve project root directory" \
			"PROJECT_ROOT may be unset or invalid" \
			"Set PROJECT_ROOT environment variable"
		return 1
	}

	[[ "$canonical_dir" == "$project_root"/* ]] || {
		vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"${PDR_ERROR_TEMPLATES[PATH_TRAVERSAL]}" \
			"PDR directory outside project bounds: $canonical_dir" \
			"${PDR_SECURITY_ACTIONS[PATH_TRAVERSAL]}"
		return 1
	}

	echo "$canonical_dir"
	return 0
}

# Critical: Path traversal prevention for PDR names
validate_pdr_name() {
	local pdr_name="$1"

	# Input validation
	[[ -n "$pdr_name" ]] || {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_INPUT" \
			"PDR name cannot be empty" \
			"validate_pdr_name called with empty parameter" \
			"Provide a valid PDR name"
		return 1
	}

	# Length validation
	[[ ${#pdr_name} -le $PDR_MAX_NAME_LENGTH ]] || {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_INPUT" \
			"${PDR_ERROR_TEMPLATES[INPUT_TOO_LARGE]}" \
			"PDR name length: ${#pdr_name} characters (max: $PDR_MAX_NAME_LENGTH)" \
			"Use shorter, descriptive PDR name"
		return 1
	}

	# Pattern validation - prevent path traversal and shell injection
	[[ "$pdr_name" =~ $PDR_NAME_PATTERN ]] || {
		vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"${PDR_ERROR_TEMPLATES[INVALID_CHARACTERS]}" \
			"PDR name contains invalid characters: $pdr_name" \
			"${PDR_SECURITY_ACTIONS[PATH_TRAVERSAL]}"
		return 1
	}

	# Explicit path traversal detection
	[[ "$pdr_name" =~ \.\./|\.\.\\ ]] && {
		vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"${PDR_ERROR_TEMPLATES[PATH_TRAVERSAL]}" \
			"Path traversal pattern detected: $pdr_name" \
			"${PDR_SECURITY_ACTIONS[PATH_TRAVERSAL]}"
		return 1
	}

	# Shell metacharacter detection
	local dangerous_chars='[$`()|;&<>{}*?!]'
	[[ "$pdr_name" =~ $dangerous_chars ]] && {
		vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"${PDR_ERROR_TEMPLATES[SHELL_INJECTION]}" \
			"Shell metacharacters detected in PDR name: $pdr_name" \
			"${PDR_SECURITY_ACTIONS[SHELL_INJECTION]}"
		return 1
	}

	return 0
}

# Critical: Secure path construction and validation
validate_pdr_path() {
	local pdr_name="$1"
	local pdr_dir="${2:-}"

	# Validate PDR name first
	validate_pdr_name "$pdr_name" || return 1

	# Get validated PDR directory
	if [[ -n "$pdr_dir" ]]; then
		pdr_dir=$(validate_pdr_directory "$pdr_dir") || return 1
	else
		pdr_dir=$(validate_pdr_directory) || return 1
	fi

	# Construct and validate final path
	local pdr_file="$pdr_dir/$pdr_name.md"
	local resolved_path
	resolved_path=$(realpath -m "$pdr_file" 2>/dev/null) || {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"${PDR_ERROR_TEMPLATES[PERMISSION_VIOLATION]}" \
			"Cannot resolve PDR file path: $pdr_file" \
			"Check PDR directory permissions and filesystem status"
		return 1
	}

	# Final boundary check
	[[ "$resolved_path" == "$pdr_dir"/* ]] || {
		vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"${PDR_ERROR_TEMPLATES[PATH_TRAVERSAL]}" \
			"Resolved path escapes PDR directory: $resolved_path" \
			"${PDR_SECURITY_ACTIONS[PATH_TRAVERSAL]}"
		return 1
	}

	echo "$resolved_path"
	return 0
}

# Critical: Input sanitization for PDR content
sanitize_pdr_content() {
	local content="$1"
	local max_size="${2:-$PDR_MAX_SIZE}"

	# Size validation
	local content_size=${#content}
	[[ $content_size -le $max_size ]] || {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_INPUT" \
			"${PDR_ERROR_TEMPLATES[INPUT_TOO_LARGE]}" \
			"Content size: $content_size bytes (max: $max_size)" \
			"${PDR_SECURITY_ACTIONS[INPUT_TOO_LARGE]}"
		return 1
	}

	# Remove dangerous HTML/JavaScript patterns
	content=$(echo "$content" | sed -E \
		-e 's/<script[^>]*>.*<\/script>//gi' \
		-e 's/<iframe[^>]*>.*<\/iframe>//gi' \
		-e 's/<object[^>]*>.*<\/object>//gi' \
		-e 's/<embed[^>]*>.*<\/embed>//gi' \
		-e 's/javascript://gi' \
		-e 's/data:text\/html/data-text-html/gi' \
		-e 's/vbscript://gi' \
		-e 's/onload=//gi' \
		-e 's/onclick=//gi' \
		-e 's/onmouseover=//gi' \
		-e 's/onerror=//gi')

	# Remove shell injection patterns
	content=$(echo "$content" | sed -E \
		-e 's/\$\([^)]*\)//g' \
		-e 's/`[^`]*`//g' \
		-e 's/\$\{[^}]*\}//g')

	# Remove format string specifiers
	content=$(echo "$content" | sed 's/%[sdxnc]//g')

	echo "$content"
	return 0
}

# Critical: Secure file creation with proper permissions
secure_pdr_file_create() {
	local pdr_file="$1"
	local content="$2"

	# Validate path first
	local parent_dir
	parent_dir=$(dirname "$pdr_file")
	[[ -d "$parent_dir" ]] || {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_FILE_ACCESS" \
			"PDR parent directory does not exist" \
			"Directory: $parent_dir" \
			"Create PDR directory structure first"
		return 1
	}

	# Set secure umask before file creation
	local old_umask
	old_umask=$(umask)
	umask 077 # Restrictive permissions during creation

	# Create file securely
	{
		touch "$pdr_file" || {
			umask "$old_umask"
			vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_FILE_ACCESS" \
				"${PDR_ERROR_TEMPLATES[PERMISSION_VIOLATION]}" \
				"Cannot create PDR file: $pdr_file" \
				"Check directory permissions and disk space"
			return 1
		}

		# Set secure permissions
		chmod 644 "$pdr_file" || {
			umask "$old_umask"
			rm -f "$pdr_file" # Clean up on permission failure
			vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PERMISSION" \
				"${PDR_ERROR_TEMPLATES[PERMISSION_VIOLATION]}" \
				"Cannot set PDR file permissions: $pdr_file" \
				"Check file ownership and ACL settings"
			return 1
		}

		# Write content securely
		echo "$content" >"$pdr_file" || {
			umask "$old_umask"
			rm -f "$pdr_file" # Clean up on write failure
			vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_FILE_ACCESS" \
				"Cannot write PDR content to file" \
				"File: $pdr_file" \
				"Check disk space and file permissions"
			return 1
		}

	}

	# Restore original umask
	umask "$old_umask"
	return 0
}

# Critical: File locking mechanism for race condition prevention
# PDR lock directory (with guard)
if [[ -z "$PDR_LOCK_DIR" ]]; then
	PDR_LOCK_DIR="/tmp/pdr_locks_$(id -u)"
fi

acquire_pdr_lock() {
	local lock_name="$1"
	local timeout="${2:-30}"
	local count=0

	# Create lock directory securely
	[[ -d "$PDR_LOCK_DIR" ]] || {
		mkdir -p "$PDR_LOCK_DIR" || {
			vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PERMISSION" \
				"Cannot create PDR lock directory" \
				"Directory: $PDR_LOCK_DIR" \
				"Check /tmp permissions and available space"
			return 1
		}
		chmod 700 "$PDR_LOCK_DIR"
	}

	local lock_file="$PDR_LOCK_DIR/$lock_name.lock"

	# Attempt to acquire lock with timeout
	while [[ $count -lt $timeout ]]; do
		if (
			set -C
			echo $$ >"$lock_file"
		) 2>/dev/null; then
			return 0 # Lock acquired successfully
		fi

		# Check if lock holder is still alive
		if [[ -f "$lock_file" ]]; then
			local lock_pid
			lock_pid=$(cat "$lock_file" 2>/dev/null)
			if [[ -n "$lock_pid" ]] && ! kill -0 "$lock_pid" 2>/dev/null; then
				# Stale lock, remove it
				rm -f "$lock_file" 2>/dev/null
				continue
			fi
		fi

		sleep 1
		((count++))
	done

	vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PROCESS" \
		"${PDR_ERROR_TEMPLATES[RACE_CONDITION]}" \
		"Failed to acquire lock after ${timeout}s: $lock_name" \
		"${PDR_SECURITY_ACTIONS[RACE_CONDITION]}"
	return 1
}

release_pdr_lock() {
	local lock_name="$1"
	local lock_file="$PDR_LOCK_DIR/$lock_name.lock"

	[[ -f "$lock_file" ]] && rm -f "$lock_file"
}

# Critical: Safe git operations for PDR system
safe_git_add_pdr() {
	local pdr_file="$1"

	# Validate file exists and is within project
	[[ -f "$pdr_file" ]] || {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_FILE_ACCESS" \
			"PDR file not found for git add" \
			"File: $pdr_file" \
			"Ensure PDR file was created successfully"
		return 1
	}

	# Use array to prevent shell injection
	local git_add_cmd=(git add "$pdr_file")

	"${git_add_cmd[@]}" || {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PROCESS" \
			"Git add operation failed for PDR" \
			"File: $pdr_file" \
			"Check git repository status and file permissions"
		return 1
	}

	return 0
}

safe_git_commit_pdr() {
	local pdr_name="$1"
	local message="$2"

	# Sanitize commit message
	message=$(sanitize_commit_message "$message")

	# Use array for safe parameter passing
	local git_commit_cmd=(git commit -m "$message")

	"${git_commit_cmd[@]}" || {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PROCESS" \
			"Git commit operation failed for PDR" \
			"PDR: $pdr_name" \
			"Check git configuration and repository status"
		return 1
	}

	return 0
}

# Critical: Commit message sanitization
sanitize_commit_message() {
	local message="$1"

	# Remove potentially dangerous characters
	message=$(echo "$message" | tr -d '\000-\037\177')    # Remove control characters
	message=$(echo "$message" | sed 's/[`$(){}|;&<>]//g') # Remove shell metacharacters

	# Limit message length
	if [[ ${#message} -gt 100 ]]; then
		message="${message:0:97}..."
	fi

	# Ensure non-empty message
	[[ -n "$message" ]] || message="PDR update"

	echo "$message"
}

# Input validation for search queries
validate_search_query() {
	local query="$1"
	local max_length="${2:-200}"

	# Length validation
	[[ ${#query} -le $max_length ]] || {
		vpn_error "$ERROR_MEDIUM" "$PDR_COMPONENT" "$ERR_INPUT" \
			"${PDR_ERROR_TEMPLATES[INPUT_TOO_LARGE]}" \
			"Search query length: ${#query} characters (max: $max_length)" \
			"Use shorter, more specific search terms"
		return 1
	}

	# Prevent regex DoS attacks
	local complexity_patterns='(\*{3,}|\+{3,}|\.{10,}|\?{5,})'
	[[ "$query" =~ $complexity_patterns ]] && {
		vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_SECURITY" \
			"Search query contains complex patterns that could cause performance issues" \
			"Pattern detected in: $query" \
			"Use simpler search terms without repeated wildcards"
		return 1
	}

	return 0
}

# Critical security test function
test_pdr_security() {
	echo "=== PDR Security Validation Tests ==="
	local test_count=0
	local passed_count=0

	# Test 1: Path traversal prevention
	((test_count++))
	if ! validate_pdr_name "../../../etc/passwd" >/dev/null 2>&1; then
		echo "✅ Path traversal prevention working"
		((passed_count++))
	else
		echo "❌ Path traversal prevention failed"
	fi

	# Test 2: Shell injection prevention
	((test_count++))
	if ! validate_pdr_name "test; rm -rf /" >/dev/null 2>&1; then
		echo "✅ Shell injection prevention working"
		((passed_count++))
	else
		echo "❌ Shell injection prevention failed"
	fi

	# Test 3: Content sanitization
	((test_count++))
	local malicious_content='<script>alert("xss")</script>$(rm -rf /)'
	local sanitized_content
	sanitized_content=$(sanitize_pdr_content "$malicious_content")
	if [[ "$sanitized_content" != *"<script>"* ]] && [[ "$sanitized_content" != *'$(rm'* ]]; then
		echo "✅ Content sanitization working"
		((passed_count++))
	else
		echo "❌ Content sanitization failed"
	fi

	# Test 4: File permissions
	((test_count++))
	local test_file="/tmp/pdr_test_$(date +%s).md"
	if secure_pdr_file_create "$test_file" "test content" >/dev/null 2>&1; then
		local perms
		perms=$(stat -c %a "$test_file" 2>/dev/null)
		rm -f "$test_file"
		if [[ "$perms" == "644" ]]; then
			echo "✅ Secure file permissions working"
			((passed_count++))
		else
			echo "❌ File permissions incorrect: $perms"
		fi
	else
		echo "❌ Secure file creation failed"
	fi

	echo "=== Security Test Results: $passed_count/$test_count passed ==="
	return $((test_count - passed_count))
}

# Ensure this is being sourced, not executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	echo "PDR Security Library - Run security tests"
	test_pdr_security
	exit $?
fi
