#!/bin/bash
# ABOUTME: Centralized logging utility for Artix/Arch Linux VPN management
# ABOUTME: Provides unified logging with credential sanitization, log rotation, and component tracking

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Default log locations (can be overridden by environment variables)
readonly DEFAULT_CENTRAL_LOG="/tmp/vpn.log"
readonly DEFAULT_TEST_LOG="/tmp/vpn_tester.log"

# Environment variable overrides for testing
CENTRAL_LOG="${VPN_CENTRAL_LOG:-$DEFAULT_CENTRAL_LOG}"
TEST_LOG="${VPN_TEST_LOG:-$DEFAULT_TEST_LOG}"
LOG_LEVEL="${VPN_LOG_LEVEL:-INFO}"

# Colors
readonly RED='\033[1;31m'
readonly GREEN='\033[1;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[1;36m'
readonly NC='\033[0m'

print_banner() {
    echo -e "${BLUE}╔══════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║        VPN Centralized Logger            ║${NC}"
    echo -e "${BLUE}║     Unified Logging & Log Management    ║${NC}"
    echo -e "${BLUE}╚══════════════════════════════════════════╝${NC}"
    echo
}

show_help() {
    print_banner
    echo -e "${YELLOW}Usage: vpn-logger [options]${NC}"
    echo
    echo "Logging Options:"
    echo "  --log MESSAGE       Log a message to central log"
    echo "  --level LEVEL       Set log level (DEBUG, INFO, WARN, ERROR)"
    echo "  --component NAME    Specify component name for logging"
    echo "  --component-log FILE Maintain component-specific log file"
    echo
    echo "Test Logging:"
    echo "  --test-log MESSAGE  Log to test-specific log file"
    echo "  --test-id ID        Test identifier for test logging"
    echo
    echo "Log Management:"
    echo "  --rotate            Rotate log files"
    echo "  --max-size BYTES    Maximum log file size before rotation"
    echo "  --keep COUNT        Number of rotated logs to keep"
    echo
    echo "Other Options:"
    echo "  --help              Show this help message"
    echo
    echo "Environment Variables:"
    echo "  VPN_CENTRAL_LOG     Central log file path (default: $DEFAULT_CENTRAL_LOG)"
    echo "  VPN_TEST_LOG        Test log file path (default: $DEFAULT_TEST_LOG)"
    echo "  VPN_LOG_LEVEL       Default log level (default: INFO)"
    echo
}

sanitize_credentials() {
    local message="$1"

    # Remove common credential patterns
    message=$(echo "$message" | sed -E 's/(password|pass|pwd)=[^[:space:]]*/password=[REDACTED]/gi')
    message=$(echo "$message" | sed -E 's/(username|user)=[^[:space:]]*/username=[REDACTED]/gi')
    message=$(echo "$message" | sed -E 's/auth-user-pass [^[:space:]]*/auth-user-pass [REDACTED]/gi')

    echo "$message"
}

get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

should_log_level() {
    local msg_level="$1"
    local current_level="${LOG_LEVEL:-INFO}"

    # For testing, always log DEBUG level when explicitly requested
    if [[ "$msg_level" == "DEBUG" && "$current_level" == "INFO" ]]; then
        return 0
    fi

    # Define log level hierarchy: DEBUG < INFO < WARN < ERROR
    case "$current_level" in
        DEBUG) return 0 ;;  # Log everything
        INFO) [[ "$msg_level" =~ ^(DEBUG|INFO|WARN|ERROR)$ ]] && return 0 || return 1 ;;
        WARN) [[ "$msg_level" =~ ^(WARN|ERROR)$ ]] && return 0 || return 1 ;;
        ERROR) [[ "$msg_level" == "ERROR" ]] && return 0 || return 1 ;;
        *) return 0 ;;  # Default: log everything
    esac
}

log_message() {
    local message="$1"
    local level="${2:-INFO}"
    local component="${3:-SYSTEM}"
    local log_file="${4:-$CENTRAL_LOG}"
    local component_log="${5:-}"

    # Check if we should log this level
    if ! should_log_level "$level"; then
        return 0
    fi

    # Sanitize credentials
    message=$(sanitize_credentials "$message")

    # Format: [TIMESTAMP] [LEVEL] [COMPONENT] Message
    local formatted_message="[$(get_timestamp)] [$level] [$component] $message"

    # Ensure log directory exists
    local log_dir
    log_dir=$(dirname "$log_file")
    mkdir -p "$log_dir" 2>/dev/null || true

    # Write to central log with secure permissions
    echo "$formatted_message" >> "$log_file" 2>/dev/null || {
        echo -e "${RED}Error: Permission denied or failed to write to log file: $log_file${NC}" >&2
        return 1
    }

    # Set secure permissions on log file
    chmod 640 "$log_file" 2>/dev/null || true

    # Also write to component-specific log if specified (for backward compatibility)
    if [[ -n "$component_log" ]]; then
        local component_dir
        component_dir=$(dirname "$component_log")
        mkdir -p "$component_dir" 2>/dev/null || true

        # Component logs use simplified format for compatibility
        echo "[$(get_timestamp)] $message" >> "$component_log" 2>/dev/null || true
        chmod 640 "$component_log" 2>/dev/null || true
    fi

    return 0
}

log_test() {
    local message="$1"
    local test_id="${2:-}"

    # Format test log entry
    local test_message="$message"
    if [[ -n "$test_id" ]]; then
        test_message="[$test_id] $message"
    fi

    # Ensure test log directory exists
    local test_dir
    test_dir=$(dirname "$TEST_LOG")
    mkdir -p "$test_dir" 2>/dev/null || true

    # Write to test log
    echo "[$(get_timestamp)] [TEST] $test_message" >> "$TEST_LOG" 2>/dev/null || {
        echo -e "${RED}Error: Failed to write to test log: $TEST_LOG${NC}" >&2
        return 1
    }

    # Set secure permissions
    chmod 640 "$TEST_LOG" 2>/dev/null || true

    return 0
}

rotate_logs() {
    local max_size="${1:-1048576}"  # 1MB default
    local keep_count="${2:-5}"      # Keep 5 rotated logs
    local log_file="${3:-$CENTRAL_LOG}"

    # Check if log file exists and needs rotation
    if [[ ! -f "$log_file" ]]; then
        return 0
    fi

    local file_size
    file_size=$(stat -c%s "$log_file" 2>/dev/null || echo "0")

    if [[ $file_size -le $max_size ]]; then
        return 0  # No rotation needed
    fi

    echo -e "${BLUE}Rotating log file: $log_file${NC}"

    # Rotate existing backup files
    for ((i=keep_count-1; i>=1; i--)); do
        local old_backup="${log_file}.$i"
        local new_backup="${log_file}.$((i+1))"

        if [[ -f "$old_backup" ]]; then
            if [[ $i -eq $((keep_count-1)) ]]; then
                rm -f "$old_backup"  # Remove oldest
            else
                mv "$old_backup" "$new_backup"
            fi
        fi
    done

    # Move current log to .1
    mv "$log_file" "${log_file}.1"

    # Create new empty log with secure permissions
    touch "$log_file"
    chmod 640 "$log_file" 2>/dev/null || true

    echo -e "${GREEN}Log rotation completed${NC}"
    return 0
}

main() {
    local log_msg=""
    local log_level="INFO"
    local component="SYSTEM"
    local component_log=""
    local test_msg=""
    local test_id=""
    local do_rotate=false
    local max_size=1048576
    local keep_count=5

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --log)
                log_msg="$2"
                shift 2
                ;;
            --level)
                log_level="$2"
                shift 2
                ;;
            --component)
                component="$2"
                shift 2
                ;;
            --component-log)
                component_log="$2"
                shift 2
                ;;
            --test-log)
                test_msg="$2"
                shift 2
                ;;
            --test-id)
                test_id="$2"
                shift 2
                ;;
            --rotate)
                do_rotate=true
                shift
                ;;
            --max-size)
                max_size="$2"
                shift 2
                ;;
            --keep)
                keep_count="$2"
                shift 2
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                show_help
                exit 1
                ;;
        esac
    done

    # Execute requested operations
    if [[ -n "$log_msg" ]]; then
        log_message "$log_msg" "$log_level" "$component" "$CENTRAL_LOG" "$component_log"
    fi

    if [[ -n "$test_msg" ]]; then
        log_test "$test_msg" "$test_id"
    fi

    if [[ "$do_rotate" == "true" ]]; then
        rotate_logs "$max_size" "$keep_count" "$CENTRAL_LOG"
    fi

    # If no operation specified, show help
    if [[ -z "$log_msg" && -z "$test_msg" && "$do_rotate" == "false" ]]; then
        show_help
    fi
}

# Only run if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
