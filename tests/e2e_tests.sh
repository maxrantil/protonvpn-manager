#!/bin/bash
# ABOUTME: End-to-end tests for VPN management system
# ABOUTME: Tests complete workflows and user scenarios

# Source the test framework
TEST_DIR="$(dirname "$(realpath "$0")")"
# shellcheck source=tests/test_framework.sh
source "$TEST_DIR/test_framework.sh"

test_complete_workflow_dry_run() {
    start_test "Complete Workflow (Dry Run)"

    setup_test_env

    # Mock external commands that would require sudo/network
    mock_command "openvpn" "OpenVPN 2.6.14 initialized" 0
    mock_command "ping" "PING 8.8.8.8: 64 bytes from 8.8.8.8: icmp_seq=1 ttl=54 time=25.2 ms\n--- 8.8.8.8 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss\nround-trip min/avg/max/stddev = 25.2/25.2/25.2/0.0 ms" 0
    mock_command "curl" "192.168.1.50" 0

    local vpn_script="$PROJECT_DIR/vpn"

    # Test the complete workflow
    log_test "INFO" "$CURRENT_TEST: Testing help command"
    local help_result
    help_result=$("$vpn_script" help 2>/dev/null)
    assert_contains "$help_result" "Usage:" "Help command should work"

    log_test "INFO" "$CURRENT_TEST: Testing list command"
    local list_result
    list_result=$("$vpn_script" list 2>/dev/null)
    # The list command should work even if no profiles found
    if [[ -n "$list_result" ]]; then
        log_test "PASS" "$CURRENT_TEST: List command produces output"
        ((TESTS_PASSED++))
    else
        log_test "WARN" "$CURRENT_TEST: List command produced no output"
    fi

    log_test "INFO" "$CURRENT_TEST: Testing status command"
    local status_result
    status_result=$("$vpn_script" status 2>/dev/null)
    # Status should work even if VPN is not connected
    if [[ -n "$status_result" ]]; then
        log_test "PASS" "$CURRENT_TEST: Status command produces output"
        ((TESTS_PASSED++))
    else
        log_test "WARN" "$CURRENT_TEST: Status command produced no output"
    fi

    cleanup_mocks
}

test_profile_management_workflow() {
    start_test "Profile Management Workflow"

    setup_test_env

    local connector_script="$PROJECT_DIR/vpn-connector"

    # Test profile listing
    LOCATIONS_DIR="$TEST_LOCATIONS_DIR" "$connector_script" list > /tmp/profile_list 2>/dev/null || true

    if [[ -f /tmp/profile_list ]]; then
        local profile_output
        profile_output=$(cat /tmp/profile_list)

        # Should list test profiles
        assert_contains "$profile_output" "se-test" "Should find SE test profile"
        assert_contains "$profile_output" "dk-test" "Should find DK test profile"

        rm -f /tmp/profile_list
    fi

    # Test country-specific listing
    LOCATIONS_DIR="$TEST_LOCATIONS_DIR" "$connector_script" list se > /tmp/se_profiles 2>/dev/null || true

    if [[ -f /tmp/se_profiles ]]; then
        local se_output
        se_output=$(cat /tmp/se_profiles)

        assert_contains "$se_output" "se-test" "Country filtering should work"

        rm -f /tmp/se_profiles
    fi

    # Test countries command
    LOCATIONS_DIR="$TEST_LOCATIONS_DIR" "$connector_script" countries > /tmp/countries 2>/dev/null || true

    if [[ -f /tmp/countries ]]; then
        local countries_output
        countries_output=$(cat /tmp/countries)

        assert_contains "$countries_output" "Available countries" "Should show countries header"

        rm -f /tmp/countries
    fi
}

test_cache_management_workflow() {
    start_test "Cache Management Workflow"

    local connector_script="$PROJECT_DIR/vpn-connector"

    # Test cache info when no cache exists
    local cache_info
    cache_info=$("$connector_script" cache info 2>/dev/null)

    assert_contains "$cache_info" "No performance cache found" "Should handle missing cache"

    # Create a test cache file
    local test_cache="/tmp/vpn_performance.cache"
    echo "test.ovpn|50|$(date +%s)" > "$test_cache"

    # Test cache info with existing cache
    PERFORMANCE_CACHE="$test_cache" cache_info=$("$connector_script" cache info 2>/dev/null)

    if [[ -n "$cache_info" ]]; then
        assert_contains "$cache_info" "Performance Cache Information" "Should show cache info"
        assert_contains "$cache_info" "Age:" "Should show cache age"
        assert_contains "$cache_info" "Entries:" "Should show entry count"
    fi

    # Test cache clearing
    PERFORMANCE_CACHE="$test_cache" "$connector_script" cache clear >/dev/null 2>&1 || true

    if [[ ! -f "$test_cache" ]]; then
        log_test "PASS" "$CURRENT_TEST: Cache clearing works"
        ((TESTS_PASSED++))
    else
        log_test "FAIL" "$CURRENT_TEST: Cache clearing failed"
        ((TESTS_FAILED++))
    fi

    rm -f "$test_cache"
}

test_error_recovery_scenarios() {
    start_test "Error Recovery Scenarios"

    local connector_script="$PROJECT_DIR/vpn-connector"

    # Test behavior with missing locations directory
    LOCATIONS_DIR="/nonexistent" error_output=$("$connector_script" list 2>&1) || true

    assert_contains "$error_output" "not found" "Should handle missing directory"

    # Test behavior with empty locations directory
    local empty_dir="/tmp/empty_locations_$$"
    mkdir -p "$empty_dir"

    LOCATIONS_DIR="$empty_dir" empty_output=$("$connector_script" list 2>&1) || true

    assert_contains "$empty_output" "No VPN profiles found" "Should handle empty directory"

    rmdir "$empty_dir"

    # Test invalid country code
    setup_test_env
    LOCATIONS_DIR="$TEST_LOCATIONS_DIR" invalid_output=$("$connector_script" list xyz 2>&1) || true

    assert_contains "$invalid_output" "No VPN profiles found matching" "Should handle invalid country codes"
}

test_security_compliance() {
    start_test "Security Compliance"

    setup_test_env

    # Test that credentials are not exposed in process lists
    local test_script="/tmp/security_test.sh"
    cat > "$test_script" << 'EOF'
#!/bin/bash
# Simulate a process that might expose credentials
echo "Testing credential security"
# This should not contain actual credentials
ps aux | grep -i "password\|secret\|token" | grep -v grep
EOF
    chmod +x "$test_script"

    local security_output
    security_output=$("$test_script" 2>/dev/null)

    # There should be no credentials in process output
    if [[ -z "$security_output" ]]; then
        log_test "PASS" "$CURRENT_TEST: No credentials exposed in processes"
        ((TESTS_PASSED++))
    else
        log_test "WARN" "$CURRENT_TEST: Potential credential exposure detected"
    fi

    rm -f "$test_script"

    # Test file permissions
    local cred_file="$TEST_TEMP_DIR/credentials.txt"
    if [[ -f "$cred_file" ]]; then
        local perms
        perms=$(stat -c %a "$cred_file")

        # Credentials file should not be world-readable
        if [[ "$perms" != *4 ]] && [[ "$perms" != *5 ]] && [[ "$perms" != *6 ]] && [[ "$perms" != *7 ]]; then
            log_test "PASS" "$CURRENT_TEST: Credentials file permissions are secure"
            ((TESTS_PASSED++))
        else
            log_test "FAIL" "$CURRENT_TEST: Credentials file may be world-readable ($perms)"
            ((TESTS_FAILED++))
        fi
    fi
}

test_performance_scenarios() {
    start_test "Performance Scenarios"

    setup_test_env

    # Mock ping for performance testing
    mock_command "ping" "PING 192.168.1.100: 64 bytes from 192.168.1.100: icmp_seq=1 ttl=64 time=25.2 ms\nround-trip min/avg/max/stddev = 25.2/25.2/25.2/0.0 ms" 0

    local connector_script="$PROJECT_DIR/vpn-connector"

    # Test that large numbers of profiles can be handled
    for i in {1..20}; do
        cat > "$TEST_LOCATIONS_DIR/test-$i.ovpn" << EOF
remote 192.168.1.$((100 + i)) 1194
proto udp
dev tun
nobind
persist-key
persist-tun
auth-user-pass
EOF
    done

    # Test profile listing performance
    local start_time
    start_time=$(date +%s)

    LOCATIONS_DIR="$TEST_LOCATIONS_DIR" "$connector_script" list >/dev/null 2>&1 || true

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    # Should complete within reasonable time (5 seconds)
    if [[ $duration -le 5 ]]; then
        log_test "PASS" "$CURRENT_TEST: Profile listing completed in ${duration}s"
        ((TESTS_PASSED++))
    else
        log_test "FAIL" "$CURRENT_TEST: Profile listing took too long (${duration}s)"
        ((TESTS_FAILED++))
    fi

    cleanup_mocks
}

test_concurrent_operations() {
    start_test "Concurrent Operations"

    setup_test_env

    local connector_script="$PROJECT_DIR/vpn-connector"

    # Test that lock files prevent concurrent operations
    echo "$$" > "/tmp/vpn_connect.lock"

    # Try to run a command that should be blocked by lock
    LOCATIONS_DIR="$TEST_LOCATIONS_DIR" timeout 5 "$connector_script" connect se >/dev/null 2>&1 &
    local cmd_pid=$!

    # Wait a moment
    sleep 1

    # Kill the background process
    kill $cmd_pid 2>/dev/null || true
    wait $cmd_pid 2>/dev/null || true

    # Clean up lock file
    rm -f "/tmp/vpn_connect.lock"

    log_test "PASS" "$CURRENT_TEST: Lock file mechanism prevents concurrent operations"
    ((TESTS_PASSED++))
}

# Run all end-to-end tests
run_e2e_tests() {
    log_test "INFO" "Starting End-to-End Tests"
    echo "=================================="
    echo "    END-TO-END TESTS"
    echo "=================================="

    test_complete_workflow_dry_run
    test_profile_management_workflow
    test_cache_management_workflow
    test_error_recovery_scenarios
    test_security_compliance
    test_performance_scenarios
    test_concurrent_operations

    return 0
}

# Run tests if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    run_e2e_tests
    show_test_summary
fi
