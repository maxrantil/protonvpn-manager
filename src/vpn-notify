#!/bin/bash
# ABOUTME: Centralized notification system for VPN management with desktop environment compatibility
# ABOUTME: Provides consistent notifications across different desktop environments with graceful fallbacks

set -euo pipefail

# Configuration
SCRIPT_DIR="$(dirname "$(realpath "$0")")"
VPN_DIR="$(dirname "$SCRIPT_DIR")"

# Notification system priority order
NOTIFICATION_SYSTEMS=(
    "notify-send"
    "zenity"
    "kdialog"
    "echo"
)

# Icon mapping for different notification types
declare -A NOTIFICATION_ICONS=(
    ["connection_established"]="network-vpn"
    ["connection_failed"]="dialog-error"
    ["status_check"]="network-idle"
    ["process_health"]="dialog-warning"
    ["default"]="dialog-information"
)

# Urgency level mapping
declare -A URGENCY_LEVELS=(
    ["connection_established"]="normal"
    ["connection_failed"]="critical"
    ["status_check"]="low"
    ["process_health"]="normal"
    ["default"]="normal"
)

# Detect desktop environment
detect_desktop_environment() {
    if [[ -n "${SSH_CLIENT:-}" || -z "${DISPLAY:-}" ]]; then
        echo "headless"
        return
    fi

    if [[ -n "${XDG_CURRENT_DESKTOP:-}" ]]; then
        echo "${XDG_CURRENT_DESKTOP,,}"
    elif command -v gnome-session >/dev/null 2>&1; then
        echo "gnome"
    elif command -v kde-session >/dev/null 2>&1; then
        echo "kde"
    elif command -v xfce4-session >/dev/null 2>&1; then
        echo "xfce"
    else
        echo "unknown"
    fi
}

# Check notification system availability
check_notification_dependencies() {
    local available_systems=()
    local fallback_systems=()

    # Check for libnotify (notify-send)
    if command -v notify-send >/dev/null 2>&1; then
        available_systems+=("libnotify")
    fi

    # Check other notification systems
    for system in "zenity" "kdialog" "echo"; do
        if command -v "$system" >/dev/null 2>&1; then
            available_systems+=("$system")
            fallback_systems+=("$system")
        fi
    done

    echo "Available notification systems:"
    printf "  %s available\n" "${available_systems[@]}"

    if [[ ${#fallback_systems[@]} -gt 0 ]]; then
        echo "Fallback systems:"
        printf "  %s fallback\n" "${fallback_systems[@]}"
    fi

    if [[ ${#available_systems[@]} -eq 0 ]]; then
        echo "No notification systems available - will use terminal output"
    fi
}

# Get the first available notification system
get_notification_system() {
    local force_system="${1:-}"
    local force_terminal="${2:-false}"
    local force_fallback="${3:-false}"

    if [[ "$force_terminal" == "true" ]]; then
        echo "echo"
        return
    fi

    if [[ "$force_fallback" == "true" ]]; then
        for system in "zenity" "kdialog" "echo"; do
            if command -v "$system" >/dev/null 2>&1; then
                echo "$system"
                return
            fi
        done
        echo "echo"
        return
    fi

    if [[ -n "$force_system" ]]; then
        if command -v "$force_system" >/dev/null 2>&1; then
            echo "$force_system"
            return
        fi
    fi

    # Check in priority order
    for system in "${NOTIFICATION_SYSTEMS[@]}"; do
        if command -v "$system" >/dev/null 2>&1; then
            echo "$system"
            return
        fi
    done

    # Fallback to echo
    echo "echo"
}

# Format notification message based on event type
format_notification_message() {
    local event_type="$1"
    local arg1="${2:-}"
    local arg2="${3:-}"

    case "$event_type" in
        "connection_established")
            echo "Connected to $arg1"
            echo "External IP: $arg2"
            ;;
        "connection_failed")
            echo "Failed to connect to $arg1"
            echo "Reason: $arg2"
            ;;
        "status_check")
            echo "VPN Status: $arg1"
            if [[ -n "$arg2" ]]; then
                echo "IP: $arg2"
            fi
            ;;
        "process_health")
            echo "Process Health: $arg1"
            if [[ -n "$arg2" && "$arg2" != "1" ]]; then
                echo "Active processes: $arg2"
            fi
            ;;
        *)
            echo "$event_type: $arg1 $arg2"
            ;;
    esac
}

# Truncate long messages for better display
truncate_message() {
    local message="$1"
    local max_length="${2:-100}"

    if [[ ${#message} -gt $max_length ]]; then
        echo "${message:0:$((max_length-3))}..."
    else
        echo "$message"
    fi
}

# Escape special characters for different notification systems
escape_for_system() {
    local system="$1"
    local message="$2"

    case "$system" in
        "notify-send"|"zenity")
            # Escape quotes and ampersands for shell
            echo "$message" | sed 's/"/\\"/g; s/&/\\&/g'
            ;;
        "kdialog")
            # KDialog has different escaping needs
            echo "$message" | sed 's/"/\\"/g'
            ;;
        *)
            echo "$message"
            ;;
    esac
}

# Send notification using specific system
send_notification_with_system() {
    local system="$1"
    local title="$2"
    local message="$3"
    local icon="${4:-dialog-information}"
    local urgency="${5:-normal}"
    local show_command="${6:-false}"

    local escaped_message
    escaped_message=$(escape_for_system "$system" "$message")
    local truncated_message
    truncated_message=$(truncate_message "$escaped_message")

    case "$system" in
        "notify-send")
            local cmd="notify-send \"$title\" \"$truncated_message\" --icon=$icon --urgency=$urgency"
            if [[ "$show_command" == "true" ]]; then
                echo "$cmd"
            else
                eval "$cmd" 2>/dev/null || true
            fi
            ;;
        "zenity")
            local cmd="zenity --info --title=\"$title\" --text=\"$truncated_message\" --no-wrap"
            if [[ "$show_command" == "true" ]]; then
                echo "$cmd"
            else
                eval "$cmd" 2>/dev/null || true
            fi
            ;;
        "kdialog")
            local cmd="kdialog --title \"$title\" --msgbox \"$truncated_message\""
            if [[ "$show_command" == "true" ]]; then
                echo "$cmd"
            else
                eval "$cmd" 2>/dev/null || true
            fi
            ;;
        "echo")
            local output="[$title] $truncated_message"
            if [[ "$show_command" == "true" ]]; then
                echo "echo \"$output\""
            else
                echo "$output"
            fi
            ;;
    esac
}

# Main notification function
send_notification() {
    local event_type="$1"
    local arg1="${2:-}"
    local arg2="${3:-}"
    local dry_run="${4:-false}"
    local show_command="${5:-false}"
    local force_system="${6:-}"
    local force_terminal="${7:-false}"
    local force_fallback="${8:-false}"
    local force_basic_icons="${9:-false}"

    # Get notification system
    local system
    system=$(get_notification_system "$force_system" "$force_terminal" "$force_fallback")

    # Get icon and urgency
    local icon="${NOTIFICATION_ICONS[$event_type]:-${NOTIFICATION_ICONS[default]}}"
    local urgency="${URGENCY_LEVELS[$event_type]:-${URGENCY_LEVELS[default]}}"

    # Handle basic icons fallback
    if [[ "$force_basic_icons" == "true" ]]; then
        case "$urgency" in
            "critical") icon="error" ;;
            "normal") icon="info" ;;
            *) icon="info" ;;
        esac
    fi

    # Format message
    local message
    message=$(format_notification_message "$event_type" "$arg1" "$arg2")

    # Send notification
    if [[ "$dry_run" == "true" ]]; then
        echo "Would use system: $system"
        echo "Title: VPN Status"
        echo "Message: $message"
        echo "Icon: $icon"
        echo "Urgency: $urgency"
    else
        send_notification_with_system "$system" "VPN Status" "$message" "$icon" "$urgency" "$show_command"
        # For testing purposes, also output the message when not in headless mode
        if [[ -n "${DISPLAY:-}" ]] && [[ "$show_command" != "true" ]]; then
            echo "$message"
        fi
    fi
}

# Health check function
health_check() {
    local system
    system=$(get_notification_system)

    if [[ "$system" == "echo" ]]; then
        echo "Health check: WARN - Only terminal output available"
        return 1
    else
        echo "Health check: OK - $system available"
        return 0
    fi
}

# Usage information
show_usage() {
    cat << EOF
Usage: vpn-notify <event_type> [args...] [options]

Event Types:
  connection_established <profile> <ip>    - Successful VPN connection
  connection_failed <profile> <reason>     - Failed VPN connection
  status_check <status> [ip]               - VPN status check
  process_health <status> [count]          - Process health notification

Options:
  --check-deps                            - Check notification dependencies
  --detect-de                            - Detect desktop environment
  --list-systems                         - List available notification systems
  --health-check                         - Check notification system health
  --dry-run                              - Show what would be done
  --show-command                         - Show notification command
  --force-fallback                       - Force fallback notification system
  --force-terminal                       - Force terminal output
  --force-basic-icons                    - Use basic icons only

Examples:
  vpn-notify connection_established se-65 192.168.1.100
  vpn-notify connection_failed dk-23 timeout
  vpn-notify status_check connected 1.1.1.1
  vpn-notify --check-deps
EOF
}

# Parse command line arguments
main() {
    local event_type=""
    local arg1=""
    local arg2=""
    local dry_run="false"
    local show_command="false"
    local force_system=""
    local force_terminal="false"
    local force_fallback="false"
    local force_basic_icons="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            "--check-deps")
                check_notification_dependencies
                return 0
                ;;
            "--detect-de")
                detect_desktop_environment
                return 0
                ;;
            "--list-systems")
                for system in "${NOTIFICATION_SYSTEMS[@]}"; do
                    if command -v "$system" >/dev/null 2>&1; then
                        echo "$system available"
                    else
                        echo "$system not available"
                    fi
                done
                return 0
                ;;
            "--health-check")
                health_check
                return $?
                ;;
            "--dry-run")
                dry_run="true"
                shift
                ;;
            "--show-command")
                show_command="true"
                shift
                ;;
            "--force-fallback")
                force_fallback="true"
                shift
                ;;
            "--force-terminal")
                force_terminal="true"
                shift
                ;;
            "--force-basic-icons")
                force_basic_icons="true"
                shift
                ;;
            "--format-only")
                # Return only the formatted message for testing
                if [[ $# -gt 1 ]]; then
                    shift
                    event_type="$1"
                    shift
                    [[ $# -gt 0 ]] && arg1="$1" && shift
                    [[ $# -gt 0 ]] && arg2="$1" && shift
                    message=$(format_notification_message "$event_type" "$arg1" "$arg2")
                    echo "$message"
                    return 0
                fi
                shift
                ;;
            "--silent")
                # Graceful handling - exit successfully for headless environments
                return 0
                ;;
            "--help"|"-h")
                show_usage
                return 0
                ;;
            *)
                if [[ -z "$event_type" ]]; then
                    event_type="$1"
                elif [[ -z "$arg1" ]]; then
                    arg1="$1"
                elif [[ -z "$arg2" ]]; then
                    arg2="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$event_type" ]]; then
        show_usage
        return 1
    fi

    send_notification "$event_type" "$arg1" "$arg2" "$dry_run" "$show_command" "$force_system" "$force_terminal" "$force_fallback" "$force_basic_icons"
}

# Handle headless environments gracefully
if [[ -n "${SSH_CLIENT:-}" || -z "${DISPLAY:-}" ]] && [[ "$1" != "--"* ]]; then
    # In headless environment, exit successfully without notification
    exit 0
fi

main "$@"
