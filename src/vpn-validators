#!/bin/bash
# ABOUTME: Input validation library for VPN scripts - validates paths, files, and inputs before privilege escalation
# ABOUTME: Prevents path traversal, symlink attacks, and unauthorized file access

# Validate profile path before sudo operations
# Args: $1 = path to validate, $2 = allowed directory (defaults to LOCATIONS_DIR)
# Returns: 0 on success, 1 on failure
validate_profile_path() {
    local path="$1"
    local allowed_dir="${2:-$LOCATIONS_DIR}"

    # Input must be provided
    if [[ -z "$path" ]]; then
        echo "ERROR: Profile path cannot be empty" >&2
        return 1
    fi

    # Must exist
    if [[ ! -e "$path" ]]; then
        echo "ERROR: Profile does not exist: $path" >&2
        return 1
    fi

    # Must be regular file (not symlink, directory, device, etc.)
    if [[ ! -f "$path" ]] || [[ -L "$path" ]]; then
        echo "ERROR: Profile must be a regular file, not symlink: $path" >&2
        return 1
    fi

    # Resolve to canonical path (follows symlinks, resolves ..)
    local canonical
    canonical=$(realpath "$path" 2>/dev/null) || {
        echo "ERROR: Cannot resolve canonical path: $path" >&2
        return 1
    }

    # Canonical path must be within allowed directory
    local allowed_canonical
    allowed_canonical=$(realpath "$allowed_dir" 2>/dev/null) || {
        echo "ERROR: Cannot resolve allowed directory: $allowed_dir" >&2
        return 1
    }

    if [[ ! "$canonical" =~ ^"$allowed_canonical"/ ]]; then
        echo "ERROR: Profile path outside allowed directory" >&2
        echo "  Profile: $canonical" >&2
        echo "  Allowed: $allowed_canonical" >&2
        return 1
    fi

    # Must have safe extension
    if [[ ! "$canonical" =~ \.(ovpn|conf)$ ]]; then
        echo "ERROR: Invalid profile extension (must be .ovpn or .conf)" >&2
        return 1
    fi

    # Additional check: no special characters that might cause issues
    if [[ "$canonical" =~ [\$\`\\] ]]; then
        echo "ERROR: Profile path contains unsafe characters" >&2
        return 1
    fi

    # Validate file ownership (must be owned by current user or root)
    local file_owner
    file_owner=$(stat -c "%U" "$canonical" 2>/dev/null)
    if [[ "$file_owner" != "$(whoami)" ]] && [[ "$file_owner" != "root" ]]; then
        echo "ERROR: Profile file has suspicious ownership: $file_owner" >&2
        return 1
    fi

    # All checks passed
    return 0
}

# Validate credentials file (stricter than regular profiles)
# Args: $1 = credentials file path
# Returns: 0 on success, 1 on failure
validate_credentials_file() {
    local cred_file="$1"

    if [[ -z "$cred_file" ]]; then
        echo "ERROR: Credentials file path cannot be empty" >&2
        return 1
    fi

    if [[ ! -f "$cred_file" ]]; then
        echo "ERROR: Credentials file not found: $cred_file" >&2
        return 1
    fi

    # Must not be symlink (strict security)
    if [[ -L "$cred_file" ]]; then
        echo "ERROR: Credentials file must not be a symlink" >&2
        return 1
    fi

    # Must be owned by current user
    local owner
    owner=$(stat -c "%U" "$cred_file" 2>/dev/null)
    if [[ "$owner" != "$(whoami)" ]]; then
        echo "ERROR: Credentials file must be owned by current user" >&2
        return 1
    fi

    # Must have 600 permissions
    local perms
    perms=$(stat -c "%a" "$cred_file" 2>/dev/null)
    if [[ "$perms" != "600" ]]; then
        echo "ERROR: Credentials file must have 600 permissions, has $perms" >&2
        return 1
    fi

    return 0
}

# Validate and secure credentials file (fixes permissions if needed)
# Args: $1 = credentials file path
# Returns: 0 on success, 1 on failure
validate_and_secure_credentials() {
    local cred_file="$1"

    if [[ ! -f "$cred_file" ]]; then
        echo "ERROR: Credentials file not found: $cred_file" >&2
        return 1
    fi

    # Check for symlink
    if [[ -L "$cred_file" ]]; then
        echo "ERROR: Credentials file must not be a symlink" >&2
        return 1
    fi

    # Check ownership
    local owner
    owner=$(stat -c "%U" "$cred_file" 2>/dev/null)
    if [[ "$owner" != "$(whoami)" ]]; then
        echo "ERROR: Credentials file must be owned by current user (owner: $owner)" >&2
        return 1
    fi

    # Check and fix permissions
    local perms
    perms=$(stat -c "%a" "$cred_file" 2>/dev/null)

    if [[ "$perms" != "600" ]]; then
        echo "WARNING: Insecure credentials file permissions: $perms" >&2
        echo "Attempting to secure credentials file..." >&2

        # Attempt to fix
        if ! chmod 600 "$cred_file" 2>/dev/null; then
            echo "FATAL: Cannot change credentials file permissions" >&2
            echo "  File: $cred_file" >&2
            echo "  Current permissions: $perms" >&2
            echo "  Required permissions: 600" >&2
            echo "  Fix manually: chmod 600 $cred_file" >&2
            return 1
        fi

        # Re-verify after change (HIGH-5 fix)
        perms=$(stat -c "%a" "$cred_file" 2>/dev/null)
        if [[ "$perms" != "600" ]]; then
            echo "FATAL: Permissions remain insecure after chmod attempt" >&2
            echo "  Current: $perms" >&2
            echo "  Required: 600" >&2
            echo "  This may indicate a read-only filesystem or security policy" >&2
            return 1
        fi

        echo "âœ“ Credentials file secured with 600 permissions" >&2
    fi

    return 0
}

# Validate country code format
# Args: $1 = country code
# Returns: 0 on success, 1 on failure
validate_country_code() {
    local code="$1"

    # Length check
    [[ ${#code} -eq 2 ]] || return 1

    # Only lowercase letters
    [[ "$code" =~ ^[a-z]{2}$ ]] || return 1

    # Optional: Whitelist known codes (can be extended)
    local supported="se dk no nl de ch us uk fr ca jp au is br"
    [[ " $supported " == *" $code "* ]] || {
        echo "WARNING: Unknown country code: $code" >&2
        return 1
    }

    return 0
}

# Sanitize user input (remove dangerous characters)
# Args: $1 = input string
# Returns: sanitized string on stdout, 0 on success, 1 on failure
sanitize_user_input() {
    local input="$1"
    local max_length=255

    # Length limit
    if [[ ${#input} -gt $max_length ]]; then
        echo "ERROR: Input exceeds maximum length" >&2
        return 1
    fi

    # No null bytes
    if [[ "$input" =~ $'\0' ]]; then
        echo "ERROR: Invalid characters in input" >&2
        return 1
    fi

    # Reject dangerous shell metacharacters in certain contexts
    if [[ "$input" =~ [\$\`\;] ]]; then
        echo "ERROR: Unsafe characters in input" >&2
        return 1
    fi

    echo "$input"
}

# Export functions for use in other scripts
export -f validate_profile_path
export -f validate_credentials_file
export -f validate_and_secure_credentials
export -f validate_country_code
export -f sanitize_user_input
