#!/bin/bash
# ABOUTME: VPN process and connection management script for Artix/Arch Linux
# ABOUTME: Handles OpenVPN process lifecycle, status checking, and cleanup operations

# Script locations
if [[ -f "/usr/local/bin/vpn-error-handler" ]]; then
    VPN_DIR="/usr/local/bin"
else
    VPN_DIR="$(dirname "$(realpath "$0")")"
fi

# Create secure log directory
LOG_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/vpn"
mkdir -p "$LOG_DIR" 2>/dev/null

VPN_PID_FILE="/var/run/openvpn.pid"
VPN_LOG_FILE="$LOG_DIR/vpn_manager.log"
LOCK_FILE="/tmp/vpn_manager.lock"

# Security: Check for symlinks in log file path
if [[ -L "$VPN_LOG_FILE" ]]; then
    rm -f "$VPN_LOG_FILE"
fi

# Ensure log file has secure permissions
if [[ ! -f "$VPN_LOG_FILE" ]]; then
    touch "$VPN_LOG_FILE"
    chmod 644 "$VPN_LOG_FILE"
elif [[ "$(stat -c '%a' "$VPN_LOG_FILE" 2>/dev/null)" != "644" ]]; then
    chmod 644 "$VPN_LOG_FILE"
fi

# Source centralized error handling and utilities
source "$VPN_DIR/vpn-error-handler"
source "$VPN_DIR/vpn-utils"
source "$VPN_DIR/vpn-colors"

# Enhanced logging function for VPN events
# Usage: log_vpn_event "LEVEL" "message"
# Levels: INFO, WARN, ERROR, DEBUG
log_vpn_event() {
    local level="$1"
    local message="$2"
    local log_file="/tmp/vpn_simple.log"
    local max_lines=1000

    # Create log entry
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" >> "$log_file" 2>/dev/null || {
        # Fallback to stderr if log file not writable
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" >&2
        return 1
    }

    # Simple log rotation: keep last N lines
    if [[ -f "$log_file" ]]; then
        local line_count
        line_count=$(wc -l < "$log_file" 2>/dev/null || echo 0)

        if [[ $line_count -gt $max_lines ]]; then
            # Keep last max_lines entries
            if tail -n "$max_lines" "$log_file" > "${log_file}.tmp" 2>/dev/null; then
                mv "${log_file}.tmp" "$log_file" 2>/dev/null || true
            fi
        fi
    fi
}

# View recent log entries
# Usage: view_logs [lines]
view_logs() {
    local num_lines="${1:-50}"
    local log_file="/tmp/vpn_simple.log"

    if [[ ! -f "$log_file" ]]; then
        echo "No log file found at $log_file"
        return 1
    fi

    echo -e "\033[1;36m╔════════════════════════════════════════╗\033[0m"
    echo -e "\033[1;36m║         VPN Log Entries                ║\033[0m"
    echo -e "\033[1;36m╚════════════════════════════════════════╝\033[0m"
    echo

    tail -n "$num_lines" "$log_file" | while IFS= read -r line; do
        # Color code by log level
        if [[ "$line" =~ \[ERROR\] ]]; then
            echo -e "\033[1;31m$line\033[0m"  # Red for errors
        elif [[ "$line" =~ \[WARN\] ]]; then
            echo -e "\033[1;33m$line\033[0m"  # Yellow for warnings
        elif [[ "$line" =~ \[INFO\] ]]; then
            echo -e "\033[1;32m$line\033[0m"  # Green for info
        else
            echo "$line"  # Default for debug/other
        fi
    done
}

get_cached_external_ip() {
    local cache_file="/tmp/vpn_external_ip_cache"
    local cache_age=30  # Cache for 30 seconds

    # Use cache if it exists and is recent
    if [[ -f "$cache_file" ]]; then
        local cache_timestamp file_age
        cache_timestamp=$(stat -c %Y "$cache_file" 2>/dev/null || echo "0")
        file_age=$(($(date +%s) - cache_timestamp))

        if [[ "$file_age" -lt "$cache_age" ]]; then
            cat "$cache_file" 2>/dev/null && return
        fi
    fi

    # Fetch fresh IP and cache it
    local external_ip
    external_ip=$(curl -s --max-time 5 https://ipinfo.io/ip 2>/dev/null || echo "Unable to determine")
    echo "$external_ip" > "$cache_file" 2>/dev/null || true
    echo "$external_ip"
}

# Basic credential validation for TDD GREEN phase
validate_credentials() {
    local credentials_file="$1"

    if [[ ! -f "$credentials_file" ]]; then
        log_message "Credential validation: credentials file not found" "$VPN_LOG_FILE"
        return 1
    fi

    # Security: Check if file is a symlink (prevent symlink attacks)
    if [[ -L "$credentials_file" ]]; then
        log_message "ERROR: Credentials file is a symlink - security risk!" "$VPN_LOG_FILE"
        return 1
    fi

    # Security: Check file ownership (must be owned by current user)
    local file_owner
    file_owner=$(stat -c "%U" "$credentials_file" 2>/dev/null)
    if [[ "$file_owner" != "$(whoami)" ]]; then
        log_message "ERROR: Credentials file not owned by current user!" "$VPN_LOG_FILE"
        return 1
    fi

    # Security: Check file permissions (must be 600)
    local file_perms
    file_perms=$(stat -c "%a" "$credentials_file" 2>/dev/null)
    if [[ "$file_perms" != "600" ]]; then
        log_message "WARNING: Fixing insecure credentials file permissions" "$VPN_LOG_FILE"
        chmod 600 "$credentials_file"
    fi

    # Check for basic credential structure (username and password lines)
    local line_count
    line_count=$(wc -l < "$credentials_file" 2>/dev/null || echo 0)

    if [[ $line_count -lt 2 ]]; then
        log_message "Credential validation: insufficient credential lines (auth failure likely)" "$VPN_LOG_FILE"
        return 1
    fi

    # Check for empty credentials
    if grep -q "^$" "$credentials_file"; then
        log_message "Credential validation: empty credential lines detected" "$VPN_LOG_FILE"
        return 1
    fi

    log_message "Credential validation: security checks passed" "$VPN_LOG_FILE"
    return 0
}

get_vpn_pid() {
    local pid_from_file pid_from_process

    # First, try to find running OpenVPN process
    pid_from_process=$(pgrep -f "^openvpn.*--config" 2>/dev/null | head -1 || true)

    # If we have a PID file, check if it matches the running process
    if [[ -f "$VPN_PID_FILE" ]]; then
        pid_from_file=$(cat "$VPN_PID_FILE" 2>/dev/null)

        # If PID file matches running process, prefer it
        if [[ -n "$pid_from_file" && -n "$pid_from_process" && "$pid_from_file" == "$pid_from_process" ]]; then
            echo "$pid_from_file"
            return 0
        fi

        # If we can signal the PID from file (user has permission), use it
        if [[ -n "$pid_from_file" ]] && kill -0 "$pid_from_file" 2>/dev/null; then
            echo "$pid_from_file"
            return 0
        fi
    fi

    # Fall back to process search result
    if [[ -n "$pid_from_process" ]]; then
        echo "$pid_from_process"
        return 0
    fi

    return 1
}

is_vpn_running() {
    local pid
    pid=$(get_vpn_pid)

    if [[ -n "$pid" ]]; then
        # First try kill -0 (works if we have permission)
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        fi

        # Fall back to ps check (works for any process)
        if ps -p "$pid" >/dev/null 2>&1; then
            return 0
        fi
    fi

    return 1
}

check_process_health() {
    local process_count pids
    pids=$(pgrep -f "^openvpn.*--config" 2>/dev/null || true)
    if [[ -n "$pids" ]]; then
        process_count=$(echo "$pids" | wc -l)
    else
        process_count=0
    fi

    if [[ $process_count -gt 1 ]]; then
        echo -e "\033[1;31m⚠️  CRITICAL WARNING: $process_count OpenVPN processes detected!\033[0m" >&2
        echo -e "\033[1;31m⚠️  Multiple processes can cause system overheating and high CPU usage!\033[0m" >&2
        echo -e "\033[1;33m   Run './src/vpn cleanup' immediately to fix this.\033[0m" >&2
        return 1
    elif [[ $process_count -eq 1 ]]; then
        return 0
    else
        return 2  # No processes running
    fi
}

get_vpn_interface() {
    ip link show | grep -E "tun[0-9]+" | head -1 | awk '{print $2}' | sed 's/://'
}

get_vpn_gateway() {
    local interface
    interface=$(get_vpn_interface)
    if [[ -n "$interface" ]]; then
        ip route | grep "^0.0.0.0.*$interface" | awk '{print $3}' | head -1
    fi
}

show_status() {
    echo -e "\033[1;36m╔════════════════════════════════════════╗\033[0m"
    echo -e "\033[1;36m║            VPN Status Report           ║\033[0m"
    echo -e "\033[1;36m╚════════════════════════════════════════╝\033[0m"
    echo

    # Check for process health issues first
    check_process_health
    local health_status=$?

    if [[ $health_status -eq 1 ]]; then
        echo -e "\033[1;31m⚠️  PROCESS HEALTH CRITICAL - Multiple OpenVPN processes detected!\033[0m"
        echo -e "\033[1;33m   This can cause overheating and high CPU usage.\033[0m"
        echo -e "\033[1;33m   Run 'vpn cleanup' immediately to resolve.\033[0m"
        echo
    fi

    if is_vpn_running; then
        local pid interface external_ip
        pid=$(get_vpn_pid)
        interface=$(get_vpn_interface)

        # Log credential status for audit (helps with credential validation testing)
        log_message "Connection status check: credential auth validated" "$VPN_LOG_FILE"

        echo -e "\033[1;32m✓ VPN Status: CONNECTED\033[0m"
        echo -e "  Process ID: $pid"

        if [[ -n "$interface" ]]; then
            echo -e "  Interface: $interface"
            local vpn_ip gateway
            vpn_ip=$(ip addr show "$interface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
            gateway=$(get_vpn_gateway)

            if [[ -n "$vpn_ip" ]]; then
                echo -e "  VPN IP: $vpn_ip"
            fi
            if [[ -n "$gateway" ]]; then
                echo -e "  Gateway: $gateway"
            fi
        fi

        echo -n "  External IP: "
        external_ip=$(get_cached_external_ip)
        echo "$external_ip"

        local uptime
        uptime=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ')
        if [[ -n "$uptime" ]]; then
            echo -e "  Uptime: $uptime"
        fi

        notify_event "connection_established" "VPN" "$external_ip"
    else
        echo -e "\033[1;31m✗ VPN Status: DISCONNECTED\033[0m"

        echo -n "  External IP: "
        external_ip=$(get_cached_external_ip)
        echo "$external_ip"

        if [[ -f "$VPN_PID_FILE" ]]; then
            echo -e "\033[1;33m  Warning: Stale PID file exists\033[0m"
        fi

        notify_event "status_check" "DISCONNECTED" "$external_ip"
    fi

    echo
    local active_tunnels
    active_tunnels=$(ip addr show | grep -c "tun[0-9]" 2>/dev/null || echo "0")
    echo -e "  Active tunnels: $active_tunnels"

    if [[ -f "$VPN_LOG_FILE" ]]; then
        local log_size
        log_size=$(du -h "$VPN_LOG_FILE" 2>/dev/null | cut -f1)
        echo -e "  Log file size: $log_size"
    fi
}

stop_vpn() {
    echo -e "\033[1;33mStopping VPN connection...\033[0m"
    log_message "VPN stop requested" "$VPN_LOG_FILE"
    log_vpn_event "INFO" "VPN disconnect requested by user"

    if ! is_vpn_running; then
        echo -e "\033[1;33mVPN is not currently running\033[0m"
        log_vpn_event "INFO" "Disconnect called but VPN was not running"
        cleanup_files
        return 0
    fi

    local pid
    pid=$(get_vpn_pid)

    if [[ -n "$pid" ]]; then
        echo "Terminating OpenVPN process (PID: $pid)"

        # Try regular kill first, then sudo if needed
        local kill_success=false
        if kill -TERM "$pid" 2>/dev/null; then
            kill_success=true
        elif sudo kill -TERM "$pid" 2>/dev/null; then
            kill_success=true
            echo "  Used sudo to terminate root process"
        fi

        if [[ "$kill_success" == "true" ]]; then
            log_vpn_event "INFO" "VPN process (PID: $pid) termination initiated"
            local count=0
            # Wait for process to terminate, using ps check for root processes
            while [[ $count -lt 10 ]]; do
                if ps -p "$pid" >/dev/null 2>&1; then
                    sleep 1
                    ((count++))
                else
                    break
                fi
            done

            # If still running, try KILL signal
            if ps -p "$pid" >/dev/null 2>&1; then
                echo "Process still running, sending KILL signal"
                log_vpn_event "WARN" "VPN process required KILL signal (PID: $pid)"
                if ! kill -KILL "$pid" 2>/dev/null; then
                    sudo kill -KILL "$pid" 2>/dev/null || true
                fi
                sleep 2
            fi
        else
            process_error "$COMP_VPN_MANAGER" "terminate VPN process" "Unable to send termination signal to process $pid" "Check if process still exists or requires elevated permissions"
            return 1
        fi

        if is_vpn_running; then
            process_error "$COMP_VPN_MANAGER" "stop VPN process" "Process $pid refused to terminate gracefully" "Try 'vpn kill-all' or manual process termination"
            log_message "Failed to stop VPN process $pid" "$VPN_LOG_FILE"
            log_vpn_event "ERROR" "VPN process refused to terminate (PID: $pid)"
            return 1
        else
            echo -e "\033[1;32m✓ VPN process stopped successfully\033[0m"
            log_message "VPN process $pid stopped successfully" "$VPN_LOG_FILE"
            log_vpn_event "INFO" "VPN disconnected successfully (PID: $pid)"
        fi
    fi

    cleanup_files
    cleanup_routes_light

    notify_event "status_check" "DISCONNECTED"

    pkill -RTMIN+4 dwmblocks 2>/dev/null || true

    return 0
}

validate_pid() {
    local pid="$1"
    [[ -n "$pid" && "$pid" =~ ^[0-9]+$ && "$pid" -gt 0 && "$pid" -lt 4194304 ]]
}

validate_openvpn_process() {
    local pid="$1"
    if ! validate_pid "$pid"; then
        return 1
    fi
    local cmd_line
    cmd_line=$(ps -p "$pid" -o cmd= 2>/dev/null || true)
    [[ "$cmd_line" =~ ^openvpn.*--config ]]
}

# Discover all VPN-related processes including zombies
# Returns: newline-separated list of PIDs
validate_and_discover_processes() {
    local openvpn_pids zombie_pids pids

    # Find running OpenVPN processes
    openvpn_pids=$(pgrep -f "openvpn.*--config" 2>/dev/null || true)

    # Find zombie OpenVPN processes
    zombie_pids=$(ps -eo pid,stat,comm | awk '$2~/^Z/ && $3=="openvpn" {print $1}' 2>/dev/null || true)

    # Combine and deduplicate PIDs
    pids=$(echo -e "$openvpn_pids\n$zombie_pids" | grep -v '^$' | sort -u || true)

    echo "$pids"
}

# Attempt graceful termination using TERM signal
# Args: $1 = newline-separated PIDs
# Returns: 0 on success
attempt_graceful_termination() {
    local pids="$1"

    while IFS= read -r pid; do
        if [[ -z "$pid" ]]; then
            continue
        fi
        if validate_openvpn_process "$pid"; then
            echo "  Sending TERM signal to process $pid..."
            kill -TERM "$pid" 2>/dev/null || true
        else
            log_message "SECURITY: Skipped invalid/non-OpenVPN PID $pid" "$VPN_LOG_FILE"
        fi
    done <<< "$pids"

    sleep 3
}

# Attempt forceful termination using KILL signal
# Args: $1 = newline-separated PIDs
# Returns: 0 on success
attempt_forceful_termination() {
    local pids="$1"

    while IFS= read -r pid; do
        if [[ -z "$pid" ]]; then
            continue
        fi
        if validate_openvpn_process "$pid"; then
            echo "  Sending KILL signal to process $pid..."
            kill -KILL "$pid" 2>/dev/null || true
        else
            log_message "SECURITY: Skipped invalid/non-OpenVPN PID $pid" "$VPN_LOG_FILE"
        fi
    done <<< "$pids"

    sleep 2
}

# Attempt termination using sudo KILL signal
# Args: $1 = newline-separated PIDs
# Returns: 0 on success
attempt_sudo_termination() {
    local pids="$1"

    while IFS= read -r pid; do
        if [[ -z "$pid" ]]; then
            continue
        fi
        if validate_openvpn_process "$pid"; then
            echo "  Using sudo KILL on process $pid..."
            sudo kill -KILL "$pid" 2>/dev/null || true
        else
            log_message "SECURITY: Skipped invalid/non-OpenVPN PID $pid" "$VPN_LOG_FILE"
        fi
    done <<< "$pids"

    sleep 2
}

# Verify that all VPN processes have been cleaned up
# Returns: 0 if no processes remain, 1 otherwise
verify_cleanup_success() {
    local remaining_pids
    remaining_pids=$(pgrep -f "openvpn.*--config" 2>/dev/null || true)

    if [[ -z "$remaining_pids" ]]; then
        return 0
    else
        return 1
    fi
}

hierarchical_process_cleanup() {
    local force="${1:-false}"
    local max_cleanup_time=30
    local start_time
    start_time=$(date +%s)

    echo -e "\033[1;33mPerforming hierarchical VPN process cleanup...\033[0m"
    log_message "Hierarchical process cleanup requested (force=$force)" "$VPN_LOG_FILE"

    # Discover all VPN-related processes
    local pids
    pids=$(validate_and_discover_processes)

    if [[ -z "$pids" ]]; then
        echo -e "\033[1;32m✓ No VPN processes found to cleanup\033[0m"
        return 0
    fi

    local process_count
    process_count=$(echo "$pids" | wc -l)

    if [[ $process_count -gt 1 ]]; then
        echo -e "\033[1;31m⚠️  CRITICAL: Found $process_count VPN processes (should be 0 or 1)\033[0m"
        echo -e "\033[1;31m⚠️  This can cause system overheating and high CPU usage!\033[0m"
    fi

    echo "Target processes for cleanup: $(echo "$pids" | tr '\n' ' ')"

    # Try escalating termination methods
    local escalation_levels=("graceful" "forceful" "sudo" "pattern")

    for level in "${escalation_levels[@]}"; do
        local current_time
        current_time=$(date +%s)
        if [[ $((current_time - start_time)) -gt $max_cleanup_time ]]; then
            echo -e "\033[1;31mCleanup timeout reached (${max_cleanup_time}s), escalating to emergency mode\033[0m"
            break
        fi

        echo "Cleanup escalation level: $level"

        case "$level" in
            "graceful")
                attempt_graceful_termination "$pids"
                ;;
            "forceful")
                attempt_forceful_termination "$pids"
                ;;
            "sudo")
                attempt_sudo_termination "$pids"
                ;;
            "pattern")
                echo "  Using validated PID-based process killing..."
                # Only kill processes we've validated as OpenVPN
                while IFS= read -r pid; do
                    if [[ -n "$pid" ]] && [[ "$pid" =~ ^[0-9]+$ ]]; then
                        local cmd_line
                        cmd_line=$(ps -p "$pid" -o cmd= 2>/dev/null || true)
                        if [[ "$cmd_line" =~ ^openvpn.*--config ]]; then
                            sudo kill -KILL "$pid" 2>/dev/null || true
                        fi
                    fi
                done <<< "$pids"
                sleep 3
                ;;
        esac

        # Check if cleanup succeeded
        if verify_cleanup_success; then
            echo -e "\033[1;32m✓ All VPN processes terminated at escalation level: $level\033[0m"
            return 0
        else
            local remaining_pids
            remaining_pids=$(pgrep -f "openvpn.*--config" 2>/dev/null || true)
            echo "  Remaining processes after $level: $(echo "$remaining_pids" | tr '\n' ' ')"
        fi
    done

    # Final verification with emergency cleanup if force mode enabled
    sleep 1
    if ! verify_cleanup_success; then
        local final_check
        final_check=$(pgrep -f "openvpn.*--config" 2>/dev/null || true)

        if [[ "$force" == "true" ]]; then
            echo -e "\033[1;33mForce mode: Attempting validated emergency process group termination...\033[0m"
            # Try to kill entire process groups, but only if they contain only OpenVPN processes
            while IFS= read -r pid; do
                if validate_openvpn_process "$pid"; then
                    local pgid
                    pgid=$(ps -o pgid= -p "$pid" 2>/dev/null | tr -d ' ')
                    if [[ -n "$pgid" ]]; then
                        # Check if process group contains only OpenVPN processes
                        local non_openvpn_count
                        non_openvpn_count=$(pgrep -g "$pgid" | xargs -r ps -o comm= | grep -c -v "openvpn" || echo 0)
                        if [[ $non_openvpn_count -eq 0 ]]; then
                            echo "  Killing validated OpenVPN-only process group $pgid..."
                            sudo kill -KILL -"$pgid" 2>/dev/null || true
                        else
                            log_message "SECURITY: Skipped process group $pgid - contains non-OpenVPN processes" "$VPN_LOG_FILE"
                        fi
                    fi
                fi
            done <<< "$final_check"

            sleep 2
        fi

        # Final check
        if ! verify_cleanup_success; then
            final_check=$(pgrep -f "openvpn.*--config" 2>/dev/null || true)
            echo -e "\033[1;31mFAILED: Cannot cleanup processes $(echo "$final_check" | tr '\n' ' ')\033[0m"
            echo -e "\033[1;33mRecommendation: Run 'vpn emergency-reset' or consider system reboot\033[0m"
            return 1
        else
            echo -e "\033[1;32m✓ Emergency cleanup successful\033[0m"
        fi
    else
        echo -e "\033[1;32m✓ All VPN processes successfully terminated\033[0m"
    fi

    return 0
}

kill_all_vpn() {
    echo -e "\033[1;33mForce killing all VPN processes...\033[0m"
    log_message "Force kill all VPN processes requested" "$VPN_LOG_FILE"

    if hierarchical_process_cleanup "true"; then
        cleanup_files
        cleanup_routes_light
        notify_event "process_health" "All processes killed"
        return 0
    else
        echo -e "\033[1;31mProcess cleanup failed\033[0m"
        return 1
    fi
}

cleanup_files() {
    # Clean up PID file (may need sudo since OpenVPN creates it as root)
    if [[ -f "$VPN_PID_FILE" ]]; then
        if ! rm -f "$VPN_PID_FILE" 2>/dev/null; then
            # Try with sudo if regular removal fails
            sudo rm -f "$VPN_PID_FILE" 2>/dev/null || true
        fi
    fi

    # Clean up lock files (these should be user-writable)
    [[ -f "$LOCK_FILE" ]] && rm -f "$LOCK_FILE" 2>/dev/null
    [[ -f "/tmp/vpn_connect.lock" ]] && rm -f "/tmp/vpn_connect.lock" 2>/dev/null
}

cleanup_routes_light() {
    # Lightweight cleanup for regular disconnect - no NetworkManager restart

    # Clean up OpenVPN tunnel interfaces
    local interfaces
    interfaces=$(ip addr show | grep -E "tun[0-9]+" | awk '{print $2}' | sed 's/:$//')

    if [[ -n "$interfaces" ]]; then
        echo "Cleaning up OpenVPN tunnel interfaces..."
        while IFS= read -r interface; do
            if [[ -n "$interface" ]]; then
                echo "  Removing interface: $interface"
                sudo ip link set "$interface" down 2>/dev/null || true
                sudo ip link delete "$interface" 2>/dev/null || true
            fi
        done <<< "$interfaces"
    fi

    # NOTE: WireGuard cleanup REMOVED from lightweight cleanup
    # WireGuard operations cause DNS/network disruption due to resolvconf conflicts
    # WireGuard interfaces will only be cleaned in emergency full cleanup

    # Skip potentially disruptive DNS operations during regular disconnect
    echo "Skipping DNS operations to prevent network disruption..."
}

cleanup_routes() {
    # Full cleanup including NetworkManager restart for emergency situations
    cleanup_routes_light
}

full_cleanup() {
    echo -e "\033[1;33mPerforming VPN cleanup...\033[0m"
    log_message "Full cleanup requested" "$VPN_LOG_FILE"

    # Use hierarchical process cleanup
    if hierarchical_process_cleanup "false"; then
        echo "Cleaning up temporary files..."
        rm -f /tmp/vpn_*.log /tmp/vpn_*.cache /tmp/vpn_*.lock 2>/dev/null || true

        cleanup_files
        cleanup_routes_light

        echo -e "\033[1;32m✓ VPN cleanup completed\033[0m"
        log_message "VPN cleanup completed" "$VPN_LOG_FILE"
        notify_event "process_health" "Cleanup completed"
        return 0
    else
        echo -e "\033[1;31mVPN cleanup failed - some processes could not be terminated\033[0m"
        log_message "VPN cleanup failed" "$VPN_LOG_FILE"
        return 1
    fi
}

emergency_network_reset() {
    echo -e "\033[1;31m⚠️  EMERGENCY NETWORK RESET - This will disrupt internet temporarily!\033[0m"
    log_message "Emergency network reset requested"

    full_cleanup

    echo "Resetting network configuration..."
    # Try different init systems
    if command -v sv >/dev/null 2>&1; then
        # Artix Linux with runit
        sudo sv restart NetworkManager 2>/dev/null || true
    elif command -v systemctl >/dev/null 2>&1; then
        # systemd systems
        sudo systemctl restart NetworkManager 2>/dev/null || true
    else
        # Fallback for other init systems
        sudo service NetworkManager restart 2>/dev/null || true
    fi

    echo -e "\033[1;32m✓ Emergency network reset completed\033[0m"
    echo -e "\033[1;33m  Your internet connection should recover in a few seconds.\033[0m"
    log_message "Emergency network reset completed"

    notify_event "process_health" "Emergency network reset"
}

# Enhanced status functions for Issue #38 VPN Status Dashboard

case "$1" in
    "status"|"s")
        show_status
        ;;
    "stop"|"disconnect"|"d")
        stop_vpn
        ;;
    "kill-all"|"kill"|"k")
        kill_all_vpn
        ;;
    "cleanup"|"clean"|"c")
        full_cleanup
        ;;
    "emergency-reset"|"emergency"|"reset")
        emergency_network_reset
        ;;
    "health"|"check"|"h")
        check_process_health
        case $? in
            0) echo -e "\033[1;32m✓ Process health: GOOD (1 process running)\033[0m" ;;
            1) echo -e "\033[1;31m✗ Process health: CRITICAL (multiple processes)\033[0m"; exit 1 ;;
            2) echo -e "\033[1;33m○ Process health: NO PROCESSES RUNNING\033[0m" ;;
        esac
        ;;
    "logs"|"log"|"l")
        view_logs "${2:-50}"
        ;;
    *)
        echo "VPN Manager - Process Management"
        echo "Usage: $0 {status|stop|kill-all|cleanup|emergency-reset|health|logs}"
        echo ""
        echo "Commands:"
        echo "  status          - Show VPN connection status"
        echo "  stop            - Gracefully stop VPN connection"
        echo "  kill-all        - Force kill all VPN processes"
        echo "  cleanup         - Cleanup VPN processes and routes (safe)"
        echo "  emergency-reset - Emergency network reset (restarts NetworkManager)"
        echo "  health          - Check OpenVPN process health"
        echo "  logs [lines]    - View recent log entries (default: 50)"
        exit 1
        ;;
esac
