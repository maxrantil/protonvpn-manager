#!/bin/sh
# ABOUTME: Elogind sleep/wake handler for VPN reconnection on Artix Linux
# ABOUTME: Handles pre-sleep disconnect and post-wake reconnection

# Get the actual user (not root)
REAL_USER=$(who | awk 'NR==1{print $1}')
REAL_HOME=$(getent passwd "$REAL_USER" | cut -d: -f6)
REAL_GROUP=$(id -gn "$REAL_USER" 2>/dev/null)
STATE_DIR="$REAL_HOME/.local/state/vpn"
CONFIG_DIR="$REAL_HOME/.config/vpn"
LAST_PROFILE_FILE="$STATE_DIR/last_profile"
CONFIG_FILE="$CONFIG_DIR/config"
LOG_FILE="$STATE_DIR/sleep-hook.log"

log_msg() {
    echo "$(date -u +%Y-%m-%dT%H:%M:%SZ) $1" >> "$LOG_FILE" 2>/dev/null || true
}

case "${1-}" in
    'pre')
        log_msg "PRE-SLEEP: Starting"

        # Save current profile before disconnect (for auto-reconnect)
        CURRENT=$(pgrep -a openvpn 2>/dev/null | grep -o '/[^ ]*\.ovpn' | head -1)
        if [ -n "$CURRENT" ]; then
            mkdir -p "$STATE_DIR"
            echo "$CURRENT" > "$LAST_PROFILE_FILE"
            chown "$REAL_USER:$REAL_GROUP" "$LAST_PROFILE_FILE" 2>/dev/null || true
            log_msg "PRE-SLEEP: Saved profile $CURRENT"
        fi

        # Clean disconnect before sleep (but keep kill switch enabled!)
        /usr/local/bin/vpn disconnect 2>/dev/null || true
        log_msg "PRE-SLEEP: VPN disconnected"
        ;;

    'post')
        log_msg "POST-WAKE: Starting"

        # Check if auto-reconnect is enabled
        AUTO_RECONNECT="false"
        if [ -f "$CONFIG_FILE" ]; then
            AUTO_RECONNECT=$(grep '^AUTO_RECONNECT=' "$CONFIG_FILE" 2>/dev/null | cut -d= -f2 | tr -d '"' | tr -d "'")
        fi

        if [ "$AUTO_RECONNECT" != "true" ]; then
            log_msg "POST-WAKE: Auto-reconnect disabled, skipping"
            exit 0
        fi

        # Check kill switch state file (iptables rules may be lost on suspend)
        KILL_SWITCH_STATE="$STATE_DIR/kill_switch.state"
        KILL_SWITCH_WAS_ENABLED="false"
        if [ -f "$KILL_SWITCH_STATE" ]; then
            if grep -q "^status=enabled" "$KILL_SWITCH_STATE" 2>/dev/null; then
                KILL_SWITCH_WAS_ENABLED="true"
            fi
        fi

        if [ "$KILL_SWITCH_WAS_ENABLED" != "true" ]; then
            log_msg "POST-WAKE: Kill switch was not enabled before sleep, skipping auto-reconnect"
            exit 0
        fi

        # Get saved profile for reconnection
        if [ ! -f "$LAST_PROFILE_FILE" ]; then
            log_msg "POST-WAKE: No saved profile, skipping"
            exit 0
        fi

        PROFILE=$(cat "$LAST_PROFILE_FILE" 2>/dev/null)
        if [ -z "$PROFILE" ] || [ ! -f "$PROFILE" ]; then
            log_msg "POST-WAKE: Invalid profile: $PROFILE"
            exit 1
        fi
        log_msg "POST-WAKE: Will reconnect to $PROFILE"

        # Force NetworkManager to reconnect (helps with hotspot/WiFi after wake)
        log_msg "POST-WAKE: Refreshing NetworkManager connections"
        nmcli networking off 2>/dev/null || true
        sleep 1
        nmcli networking on 2>/dev/null || true

        # Wait for network to come up (max 30 seconds)
        log_msg "POST-WAKE: Waiting for network..."
        WAIT_COUNT=0
        while [ $WAIT_COUNT -lt 30 ]; do
            if nmcli networking connectivity check 2>/dev/null | grep -qE "full|limited|portal"; then
                log_msg "POST-WAKE: Network available after ${WAIT_COUNT}s"
                break
            fi
            sleep 1
            WAIT_COUNT=$((WAIT_COUNT + 1))
        done

        if [ $WAIT_COUNT -ge 30 ]; then
            log_msg "POST-WAKE: Network timeout, aborting"
            exit 1
        fi

        # Longer delay to let network fully stabilize (DNS, routing, DHCP)
        log_msg "POST-WAKE: Waiting for network to stabilize..."
        sleep 5

        # Cleanup any stale OpenVPN processes before reconnecting
        log_msg "POST-WAKE: Cleaning up stale VPN processes"
        /usr/local/bin/vpn cleanup >> "$LOG_FILE" 2>&1 || true

        # Disable kill switch temporarily to allow connection
        # iptables rules survive suspend and would block the new connection
        log_msg "POST-WAKE: Temporarily disabling kill switch for reconnection"
        /usr/local/bin/vpn-kill-switch disable >> "$LOG_FILE" 2>&1 || true

        # Extract country code from profile name (e.g., se-61.protonvpn.udp.ovpn -> se)
        COUNTRY=$(basename "$PROFILE" | sed 's/-.*//')
        log_msg "POST-WAKE: Extracted country: $COUNTRY"

        # Connect with retry logic (up to 3 attempts with increasing delays)
        ATTEMPT=1
        MAX_ATTEMPTS=3
        CONNECTED=false

        while [ $ATTEMPT -le $MAX_ATTEMPTS ] && [ "$CONNECTED" = "false" ]; do
            log_msg "POST-WAKE: Connection attempt $ATTEMPT of $MAX_ATTEMPTS to $COUNTRY"

            if /usr/local/bin/vpn connect "$COUNTRY" >> "$LOG_FILE" 2>&1; then
                CONNECTED=true
                log_msg "POST-WAKE: Reconnection successful on attempt $ATTEMPT"
            else
                log_msg "POST-WAKE: Attempt $ATTEMPT failed"
                if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                    DELAY=$((ATTEMPT * 5))
                    log_msg "POST-WAKE: Waiting ${DELAY}s before retry..."
                    sleep $DELAY
                fi
            fi
            ATTEMPT=$((ATTEMPT + 1))
        done

        if [ "$CONNECTED" = "true" ]; then
            # Re-enable kill switch AFTER connection (detects actual VPN server IP)
            log_msg "POST-WAKE: Re-enabling kill switch"
            /usr/local/bin/vpn-kill-switch enable --force >> "$LOG_FILE" 2>&1 || {
                log_msg "POST-WAKE: Warning - failed to re-enable kill switch"
            }
        else
            log_msg "POST-WAKE: All $MAX_ATTEMPTS connection attempts failed"
            # Don't enable kill switch on failed connection - user needs network access
        fi

        # Fix file ownership - this hook runs as root but files should be user-owned
        log_msg "POST-WAKE: Fixing file ownership"
        chown -R "$REAL_USER:$REAL_USER" "$STATE_DIR" 2>/dev/null || true
        ;;
esac
