#!/bin/bash
set -euo pipefail
# ABOUTME: VPN connection establishment and profile management for Artix/Arch Linux
# ABOUTME: Handles server selection, connection attempts, and performance testing

# Configuration paths
CONFIG_DIR="${VPN_CONFIG_DIR:-$HOME/.config/vpn}"
LOCATIONS_DIR="${LOCATIONS_DIR:-$CONFIG_DIR/locations}"
CREDENTIALS_FILE="${CREDENTIALS_FILE:-$CONFIG_DIR/vpn-credentials.txt}"

# Security: Hardcode trusted OpenVPN binary path to prevent PATH manipulation (Issue #165)
# HIGH-severity: Prevents privilege escalation via malicious PATH
OPENVPN_BINARY="/usr/bin/openvpn"

# Backward compatibility: Check for old credentials filename
if [[ ! -f $CREDENTIALS_FILE ]] && [[ -f "$CONFIG_DIR/credentials.txt" ]]; then
    echo "⚠️  WARNING: Found old credentials file 'credentials.txt'" >&2
    echo "   Please rename it to 'vpn-credentials.txt' for consistency:" >&2
    echo "   mv ~/.config/vpn/credentials.txt ~/.config/vpn/vpn-credentials.txt" >&2
    echo "" >&2
fi

# Script locations - robust detection for installed vs development mode
if [[ -f "/usr/local/bin/vpn-manager" ]] && [[ -f "/usr/local/bin/vpn-error-handler" ]]; then
    # Installed mode - all components in /usr/local/bin
    VPN_DIR="/usr/local/bin"
else
    # Development mode - use local paths relative to script location
    VPN_DIR="$(dirname "$(realpath "$0")")"
fi

# Source temp file manager for coordinated cleanup
# shellcheck source=src/temp-file-manager
source "$VPN_DIR/temp-file-manager" 2> /dev/null || {
    echo "Warning: Could not load temp-file-manager, temp file cleanup may be incomplete" >&2
}

# Create secure log directory
LOG_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/vpn"
mkdir -p "$LOG_DIR" 2> /dev/null

# Security: Use XDG runtime directory for lock files (prevents symlink attacks)
LOCK_DIR="${XDG_RUNTIME_DIR:-/run/user/$UID}/vpn"
if [[ ! -d $LOCK_DIR ]]; then
    mkdir -p "$LOCK_DIR" 2> /dev/null || LOCK_DIR="/tmp/vpn_$$"
    chmod 700 "$LOCK_DIR" 2> /dev/null || {
        echo "ERROR: Cannot create secure lock directory" >&2
        exit 1
    }
fi

# Verify directory permissions after creation
actual_perms=$(stat -c '%a' "$LOCK_DIR" 2> /dev/null)
if [[ $actual_perms != "700" ]]; then
    echo "ERROR: Lock directory has insecure permissions: $actual_perms" >&2
    exit 1
fi

PERFORMANCE_CACHE="$LOG_DIR/vpn_performance.cache"
CONNECTION_LOG="$LOG_DIR/vpn_connect.log"
LOCK_FILE="$LOCK_DIR/vpn_connect.lock"
PROFILE_CACHE="$LOG_DIR/vpn_profiles.cache"

# Security: Ensure log files have secure permissions (600 - only owner can read/write)
# Protection against TOCTOU race conditions and symlink attacks
for logfile in "$CONNECTION_LOG" "$PERFORMANCE_CACHE" "$PROFILE_CACHE"; do
    # Remove if symlink or non-regular file
    if [[ -L $logfile ]] || [[ -e $logfile && ! -f $logfile ]]; then
        rm -f "$logfile"
    fi

    # Atomic creation with secure permissions using noclobber
    if [[ ! -f $logfile ]]; then
        (
            set -o noclobber
            umask 077
            : > "$logfile"
        ) 2> /dev/null || {
            # File exists, verify it's not a symlink and fix permissions
            if [[ -f $logfile ]] && [[ ! -L $logfile ]]; then
                chmod 600 "$logfile" 2> /dev/null || {
                    echo "ERROR: Cannot secure log file: $logfile" >&2
                    exit 1
                }
            else
                echo "ERROR: Cannot create secure log file: $logfile" >&2
                exit 1
            fi
        }
    else
        # File exists, ensure correct permissions
        chmod 600 "$logfile" 2> /dev/null || {
            echo "ERROR: Cannot secure existing log file: $logfile" >&2
            exit 1
        }
    fi

    # Final verification: must be regular file with 600 permissions
    if [[ -L $logfile ]] || [[ "$(stat -c %a "$logfile" 2> /dev/null)" != "600" ]]; then
        echo "ERROR: Log file security verification failed: $logfile" >&2
        exit 1
    fi
done

# ============================================================================
# Stat Format Detection (Issue #73 - 25% faster cache operations)
# ============================================================================

# Detect stat format once at initialization
# Returns: Correct stat flags for mtime retrieval ("-f %m" for BSD or "-c %Y" for GNU)
detect_stat_format() {
    # Try GNU format first (most common on Linux)
    if stat -c %Y "$0" &> /dev/null; then
        echo "-c %Y"
    # Fall back to BSD format (macOS, BSD systems)
    elif stat -f %m "$0" &> /dev/null; then
        echo "-f %m"
    else
        # Fallback to GNU if neither works (shouldn't happen)
        echo "-c %Y"
    fi
}

# Initialize stat format once at script startup
# shellcheck disable=SC2034  # STAT_MTIME_FLAG used in cache functions
STAT_MTIME_FLAG=$(detect_stat_format)

# ============================================================================
# Source centralized error handling, utilities, and security validators
# ============================================================================
# Note: Sourced early to make validators available for cache functions
# Order matters: vpn-colors must be first (vpn-error-handler depends on it)

source "$VPN_DIR/vpn-colors"
source "$VPN_DIR/vpn-error-handler"
source "$VPN_DIR/vpn-utils"
source "$VPN_DIR/vpn-validators"

# ============================================================================
# Profile Cache Functions (Issue #63 - 90% performance improvement)
# ============================================================================

# Check if profile cache is valid (fresh)
# Returns: 0 if valid, 1 if invalid/stale
is_cache_valid() {
    local cache_file="$PROFILE_CACHE"

    # Check 1: Cache file must exist and be a regular file (not symlink)
    [[ -f $cache_file ]] && [[ ! -L $cache_file ]] || return 1

    # Check 2: Cache must have secure permissions (600)
    [[ "$(stat -c %a "$cache_file" 2> /dev/null)" == "600" ]] || return 1

    # Check 3: Cache must be owned by current user (prevent substitution attacks)
    [[ "$(stat -c %U "$cache_file" 2> /dev/null)" == "$(whoami)" ]] || return 1

    # Check 4: Extract cached directory mtime
    local cached_mtime
    cached_mtime=$(grep "^# CACHE_MTIME=" "$cache_file" 2> /dev/null | cut -d= -f2)
    [[ -n $cached_mtime ]] || return 1

    # Check 5: Get current directory mtime
    local current_mtime
    current_mtime=$(stat -c %Y "$LOCATIONS_DIR" 2> /dev/null)
    [[ -n $current_mtime ]] || return 1

    # Check 6: Compare timestamps (cache is valid if mtime matches)
    [[ $cached_mtime == "$current_mtime" ]]
}

# Rebuild profile cache from filesystem
# Returns: 0 on success, 1 on failure
rebuild_cache() {
    local cache_file="$PROFILE_CACHE"
    local lock_file="${cache_file}.lock"

    # Security: Acquire exclusive lock to prevent concurrent rebuild corruption (Issue #155)
    # File descriptor 201 is used for lock file
    exec 201> "$lock_file" || return 1
    if ! flock -x 201 2> /dev/null; then
        exec 201>&- # Close file descriptor on failure
        return 1
    fi

    # Security: Check if another process already rebuilt cache while we waited for lock
    if is_cache_valid; then
        exec 201>&- # Release lock
        return 0
    fi

    # Security: Use mktemp for unpredictable temp file name (prevents race conditions)
    # Use temp-file-manager if available for coordinated cleanup
    local temp_cache
    if type create_temp_file &> /dev/null; then
        temp_cache=$(create_temp_file "${cache_file}.XXXXXXXXXX") || {
            exec 201>&- # Release lock on error
            return 1
        }
    else
        # Fallback to manual temp file creation
        temp_cache=$(mktemp "${cache_file}.XXXXXXXXXX") || {
            exec 201>&- # Release lock on error
            return 1
        }
        # Ensure cleanup on any exit (use ${temp_cache:-} to handle unbound variable in strict mode)
        # Lock file will be released automatically when FD 201 closes on function exit
        trap 'rm -f "${temp_cache:-}"' RETURN

        # Security: Set restrictive permissions immediately after creation
        chmod 600 "$temp_cache" || {
            rm -f "$temp_cache"
            exec 201>&- # Release lock
            return 1
        }
    fi

    # Security: Reject symlink attacks on cache file (Issue #155 - TOCTOU fix)
    # Remove any existing cache file (including symlinks) before atomic move
    if [[ -L $cache_file ]] || [[ -e $cache_file ]]; then
        rm -f "$cache_file"
    fi

    # Get current directory mtime (cache key)
    local dir_mtime
    dir_mtime=$(stat -c %Y "$LOCATIONS_DIR" 2> /dev/null) || {
        rm -f "$temp_cache"
        exec 201>&- # Release lock
        return 1
    }

    # Build cache with metadata header and validated profiles
    # Issue #163: Validate profiles during rebuild (once), store validation signature

    # Write metadata header
    {
        echo "# VPN Profile Cache"
        echo "# CACHE_MTIME=${dir_mtime}"
        echo "# CACHE_DIR=${LOCATIONS_DIR}"
        echo "# GENERATED=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo "# CACHE_VALIDATED=1" # Issue #163: Signature indicating all entries were validated
    } > "$temp_cache" || {
        rm -f "$temp_cache"
        exec 201>&- # Release lock
        return 1
    }

    # Security: Maintain existing security model (-xtype f, maxdepth 3)
    # Issue #163: Validate each profile during rebuild (one-time validation)
    local validated_count=0
    while IFS= read -r profile_path; do
        # Validate each profile path during rebuild
        if validate_profile_path "$profile_path" "$LOCATIONS_DIR" 2> /dev/null; then
            echo "$profile_path" >> "$temp_cache"
            ((validated_count++))
        fi
    done < <(find "$LOCATIONS_DIR" -maxdepth 3 -xtype f \( -name "*.ovpn" -o -name "*.conf" \) 2> /dev/null | sort)

    # Verify we added some profiles
    if [[ $validated_count -eq 0 ]]; then
        rm -f "$temp_cache"
        exec 201>&- # Release lock
        return 1
    fi

    # Issue #163: Count is now validated_count, add to metadata
    # Insert CACHE_COUNT after CACHE_VALIDATED for consistency
    sed -i "/^# CACHE_VALIDATED=/a# CACHE_COUNT=${validated_count}" "$temp_cache" || {
        rm -f "$temp_cache"
        exec 201>&- # Release lock
        return 1
    }

    # Security: Atomic move with TOCTOU protection (Issue #155)
    # Use mv -n (no-clobber) to prevent following symlinks that may be created between rm and mv
    if ! mv -n "$temp_cache" "$cache_file" 2> /dev/null; then
        # Move failed - verify we're not being attacked
        if [[ -e $cache_file ]]; then
            # File exists - check if it's safe
            if [[ -f $cache_file ]] && [[ ! -L $cache_file ]]; then
                # Safe regular file exists - another process may have created it
                # Remove our temp file and use the existing cache
                rm -f "$temp_cache"
                exec 201>&- # Release lock
                return 0
            else
                # Symlink or other dangerous file type detected
                rm -f "$cache_file" "$temp_cache"
                exec 201>&- # Release lock
                return 1
            fi
        else
            # Move failed for other reason
            rm -f "$temp_cache"
            exec 201>&- # Release lock
            return 1
        fi
    fi

    # Success - lock will be released automatically on function exit
    return 0
}

# Get cached profile list (or rebuild if stale)
# Returns: Newline-separated list of profile paths
# Security: Validates each cached entry before returning (Issue #143)
get_cached_profiles() {
    # Validate or rebuild cache
    if ! is_cache_valid; then
        rebuild_cache || {
            # Fallback: Direct find if cache rebuild fails
            echo -e "\033[1;33mCache unavailable, using direct scan\033[0m" >&2
            find "$LOCATIONS_DIR" -maxdepth 3 -xtype f \( -name "*.ovpn" -o -name "*.conf" \) 2> /dev/null | sort
            return 0
        }
    fi

    # Security: Validate cache metadata integrity (Issue #155)
    # Detects corrupted or tampered cache files
    if ! validate_cache_metadata "$PROFILE_CACHE" 2> /dev/null; then
        # Metadata validation failed - rebuild cache
        rebuild_cache || {
            # Fallback: Direct find if cache rebuild fails
            echo -e "\033[1;33mCache metadata invalid, using direct scan\033[0m" >&2
            find "$LOCATIONS_DIR" -maxdepth 3 -xtype f \( -name "*.ovpn" -o -name "*.conf" \) 2> /dev/null | sort
            return 0
        }
    fi

    # Load cached profiles (skip header lines starting with #)
    local cached_entries
    cached_entries=$(grep -v "^#" "$PROFILE_CACHE" 2> /dev/null) || {
        # If grep fails, rebuild and try again
        rebuild_cache
        cached_entries=$(grep -v "^#" "$PROFILE_CACHE" 2> /dev/null) || echo ""
    }

    # Issue #163: Check if cache was validated during rebuild (trusted cache mode)
    local cache_validated
    cache_validated=$(grep "^# CACHE_VALIDATED=1" "$PROFILE_CACHE" 2> /dev/null)

    if [[ -n $cache_validated ]]; then
        # Trusted cache mode: All entries were validated during rebuild
        # Skip expensive per-entry validation (95% performance improvement)
        echo -n "$cached_entries"
    else
        # Legacy cache mode: Validate each entry for backwards compatibility
        # Defense-in-depth: Validate each cached entry before returning
        # Protects against cache poisoning attacks (Issue #143, M-2)
        local validated_profiles=""
        local invalid_count=0

        while IFS= read -r profile_path; do
            # Skip empty lines
            [[ -z $profile_path ]] && continue

            # Validate path using centralized validator
            # This checks: path traversal, symlinks, file existence, extension, ownership
            if validate_profile_path "$profile_path" "$LOCATIONS_DIR" 2> /dev/null; then
                validated_profiles+="$profile_path"$'\n'
            else
                # Log invalid entry (silent warning to avoid user confusion)
                ((invalid_count++))
            fi
        done <<< "$cached_entries"

        # Log summary if invalid entries were filtered
        if [[ $invalid_count -gt 0 ]]; then
            echo "WARNING: Filtered $invalid_count invalid entries from cache" >&2
        fi

        # Return validated profiles (remove trailing newline)
        echo -n "$validated_profiles"
    fi
}

# ============================================================================
# Protocol Detection Functions
# ============================================================================

detect_protocol() {
    local profile_path="$1"

    # Protocol detection: .ovpn files are OpenVPN protocol
    if [[ $profile_path == *.ovpn ]]; then
        echo "openvpn"
    # Protocol detection: .conf files are WireGuard protocol
    elif [[ $profile_path == *.conf ]]; then
        echo "wireguard"
    else
        echo "unknown"
    fi
}

validate_wireguard_config() {
    local config_path="$1"

    # Check for required WireGuard config sections
    if ! grep -q "^\[Interface\]" "$config_path"; then
        config_error "$COMP_VPN_CONNECTOR" "WireGuard" "Missing [Interface] section" "Add [Interface] section with PrivateKey and Address"
        return 1
    fi

    if ! grep -q "^\[Peer\]" "$config_path"; then
        config_error "$COMP_VPN_CONNECTOR" "WireGuard" "Missing [Peer] section" "Add [Peer] section with PublicKey and Endpoint"
        return 1
    fi

    return 0
}

check_internet() {
    if ping -c 1 -W 5 8.8.8.8 > /dev/null 2>&1; then
        return 0
    else
        network_error "$COMP_VPN_CONNECTOR" "Cannot reach external servers for connectivity test"
        return 1
    fi
}

check_dependencies() {
    local missing_deps=()

    command -v openvpn > /dev/null || missing_deps+=("openvpn")
    command -v curl > /dev/null || missing_deps+=("curl")
    command -v bc > /dev/null || missing_deps+=("bc")
    command -v notify-send > /dev/null || missing_deps+=("libnotify")
    command -v ip > /dev/null || missing_deps+=("iproute2")

    # WireGuard support - wg-quick for .conf protocol handling
    command -v wg-quick > /dev/null || missing_deps+=("wireguard-tools")

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        dependency_error "$COMP_VPN_CONNECTOR" "${missing_deps[*]}" "sudo pacman -S ${missing_deps[*]}"
        return 1
    fi

    return 0
}

acquire_lock() {
    # Security: Use flock for atomic locking (prevents race conditions)
    # File descriptor 200 is used for the lock
    exec 200> "$LOCK_FILE"
    if ! flock -n 200; then
        local lock_pid
        lock_pid=$(cat "$LOCK_FILE" 2> /dev/null)
        if [[ -n $lock_pid ]] && kill -0 "$lock_pid" 2> /dev/null; then
            echo -e "\033[1;33mAnother VPN connection is already in progress (PID: $lock_pid)\033[0m"
        else
            echo -e "\033[1;33mAnother VPN connection is in progress\033[0m"
        fi
        return 1
    fi

    # Write PID to lock file after acquiring lock
    echo $$ >&200
    return 0
}

release_lock() {
    rm -f "$LOCK_FILE" 2> /dev/null || true
}

cleanup_on_exit() {
    release_lock
    # Cleanup temp files if temp-file-manager is loaded
    if type cleanup_temp_files &> /dev/null; then
        cleanup_temp_files 2> /dev/null || true
    fi
}

# Initialize temp file manager if available
if type init_temp_file_manager &> /dev/null; then
    init_temp_file_manager 2> /dev/null || true
fi

trap cleanup_on_exit EXIT

list_profiles() {
    local filter="${1:-}"
    local show_details="${2:-}"

    if [[ ! -d $LOCATIONS_DIR ]]; then
        file_not_found_error "$COMP_VPN_CONNECTOR" "$LOCATIONS_DIR" "Create the directory and add VPN configuration files (.ovpn or .conf)"
        return 1
    fi

    local profiles
    if [[ -n $filter ]]; then
        profiles=$(find_profiles_by_country "$filter")
    else
        # Use cached profile list for performance (Issue #63)
        profiles=$(get_cached_profiles)
    fi

    if [[ -z $profiles ]]; then
        if [[ -n $filter ]]; then
            echo -e "\033[1;33mNo VPN profiles found matching: $filter\033[0m"
        else
            echo -e "\033[1;33mNo VPN profiles found in $LOCATIONS_DIR\033[0m"
            echo "Please download .ovpn files from your VPN provider"
        fi
        return 1
    fi

    local count=0
    echo -e "\033[1;36mAvailable VPN Profiles:\033[0m"
    while IFS= read -r profile; do
        local name
        name=$(basename "$profile" .ovpn)
        ((++count))

        if [[ $show_details == "detailed" ]]; then
            local server_ip country_info secure_core=""
            server_ip=$(grep -m1 "^remote " "$profile" | awk '{print $2}')

            # Check for secure core indicators using two-country-code pattern
            if echo "$name" | grep -E '^[a-z]{2}-[a-z]{2}-[0-9]+' > /dev/null; then
                # Secure core: extract entry and exit countries
                if [[ $name =~ ^([a-z]{2})-([a-z]{2})-([0-9]+) ]]; then
                    country_info=" (${BASH_REMATCH[1]^^} → ${BASH_REMATCH[2]^^})"
                    secure_core=" [SECURE CORE]"
                fi
            elif echo "$name" | grep -iq "secure\|core"; then
                # Legacy secure core detection
                secure_core=" [SECURE CORE]"
                # Extract country info from filename for legacy patterns
                if [[ $name =~ ^([a-z]{2})-([0-9]+) ]]; then
                    country_info=" (${BASH_REMATCH[1]^^})"
                fi
            else
                # Normal profile: extract single country
                if [[ $name =~ ^([a-z]{2})-([0-9]+) ]]; then
                    country_info=" (${BASH_REMATCH[1]^^})"
                else
                    country_info=""
                fi
            fi

            printf "  %-3d %-30s %-15s%s%s\n" "$count" "$name" "${server_ip:-N/A}" "$country_info" "$secure_core"
        else
            echo "  $count. $name"
        fi
    done <<< "$profiles"

    echo -e "\033[1;90mTotal: $count profiles\033[0m"
    return 0
}

detect_secure_core_profiles() {
    # Use cached profile list for performance (Issue #63)
    get_cached_profiles | while IFS= read -r profile; do
        local name
        # Handle both .ovpn and .conf extensions
        name=$(basename "$profile" | sed 's/\.\(ovpn\|conf\)$//')

        # Check for two-country-code pattern: [country1]-[country2]-[number]
        # Examples: is-br-01, se-au-01, ch-us-10
        if echo "$name" | grep -E '^[a-z]{2}-[a-z]{2}-[0-9]+' > /dev/null; then
            echo "$profile"
        # Fallback: check for legacy secure core indicators in filename or content
        elif echo "$name" | grep -iq "secure\|core\|tor"; then
            echo "$profile"
        elif grep -q "# Secure Core" "$profile" 2> /dev/null; then
            echo "$profile"
        fi
    done
}

interactive_profile_selection() {
    local filter="$1"

    local profiles
    if [[ -n $filter ]]; then
        profiles=$(find_profiles_by_country "$filter")
        echo -e "\033[1;36mProfiles matching '$filter':\033[0m"
    else
        # Use cached profile list for performance (Issue #63)
        profiles=$(get_cached_profiles)
        echo -e "\033[1;36mAll available profiles:\033[0m"
    fi

    if [[ -z $profiles ]]; then
        echo -e "\033[1;31mNo profiles found\033[0m"
        return 1
    fi

    local profile_array=()
    local count=0

    while IFS= read -r profile; do
        profile_array+=("$profile")
        local name
        name=$(basename "$profile" .ovpn)
        ((++count))

        local secure_core=""
        if echo "$name" | grep -iq "secure\|core"; then
            secure_core=" [SECURE CORE]"
        fi

        printf "  %-3d %s%s\n" "$count" "$name" "$secure_core"
    done <<< "$profiles"

    echo
    echo -n "Select profile number (1-$count) or 'q' to quit: "
    read -r selection

    if [[ $selection == "q" ]]; then
        echo "Selection cancelled"
        return 1
    fi

    if ! [[ $selection =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt $count ]]; then
        echo -e "\033[1;31mInvalid selection: $selection\033[0m"
        return 1
    fi

    local selected_profile="${profile_array[$((selection - 1))]}"
    echo -e "\033[1;32mSelected: $(basename "$selected_profile" .ovpn)\033[0m"

    connect_to_profile "$selected_profile"
}

validate_country_code() {
    local country_code="$1"

    # Security: Reject empty input
    if [[ -z $country_code ]]; then
        return 1
    fi

    # Security: Length must be exactly 2 characters
    if [[ ${#country_code} -ne 2 ]]; then
        return 1
    fi

    # Security: CRITICAL - Reject path traversal and command injection attempts
    # Only allow alphanumeric characters (a-z, A-Z, 0-9)
    if [[ ! $country_code =~ ^[a-zA-Z0-9]+$ ]]; then
        return 1
    fi

    # Security: Explicitly reject dangerous patterns
    case "$country_code" in
        */* | *\\* | *..* | *\;* | *\|* | *\&* | *\$* | *\`* | *\ *)
            return 1
            ;;
    esac

    # List of common country codes we support
    local supported_countries="se dk no nl de ch us uk fr ca jp au"

    local code_lower
    code_lower=$(echo "$country_code" | tr '[:upper:]' '[:lower:]')

    # Whitelist validation
    for supported in $supported_countries; do
        if [[ $code_lower == "$supported" ]]; then
            return 0
        fi
    done

    return 1
}

find_profiles_by_country() {
    local country_code="$1"

    if [[ -z $country_code ]]; then
        # Use cached profile list for performance (Issue #63)
        get_cached_profiles
        return
    fi

    # Security: CRITICAL - Validate country code format and reject dangerous inputs
    if ! validate_country_code "$country_code"; then
        echo -e "\033[1;31mError: Invalid country code '$country_code' - security validation failed\033[0m" >&2
        echo -e "Supported country codes: se, dk, no, nl, de, ch, us, uk, fr, ca, jp, au" >&2
        echo -e "\033[1;33mNote: Only alphanumeric 2-character codes are allowed\033[0m" >&2
        return 1
    fi

    country_code=$(echo "$country_code" | tr '[:upper:]' '[:lower:]')
    local results

    # Use cached profile list and filter by country code (Issue #63)
    results=$(get_cached_profiles | grep -E "/${country_code}-[0-9]+\.(ovpn|conf)$")

    # Secondary pattern: try variations like *_se_*, *SE*, etc.
    if [[ -z $results ]]; then
        local country_upper
        country_upper=$(echo "$country_code" | tr '[:lower:]' '[:upper:]')

        # Try different naming patterns using cached profiles
        local cached_profiles
        cached_profiles=$(get_cached_profiles)

        # Try patterns in order of preference
        for pattern in "_${country_code}_" "${country_upper}" "-${country_code}" "${country_code}[0-9]"; do
            results=$(echo "$cached_profiles" | grep -i "$pattern")
            if [[ -n $results ]]; then
                break
            fi
        done
    fi

    # Fallback: grep cached profiles for country code
    if [[ -z $results ]]; then
        results=$(get_cached_profiles | grep -i "$country_code")
    fi

    echo "$results" | sort
}

get_available_countries() {
    # Use cached profile list for performance (Issue #63)
    get_cached_profiles | while IFS= read -r profile; do
        local name
        # Handle both .ovpn and .conf extensions
        name=$(basename "$profile" | sed 's/\.\(ovpn\|conf\)$//')

        # Extract country code from common patterns
        if [[ $name =~ ^([a-z]{2})-[0-9] ]]; then
            echo "${BASH_REMATCH[1]}"
        elif [[ $name =~ _([a-z]{2})_ ]]; then
            echo "${BASH_REMATCH[1]}"
        elif [[ $name =~ ([A-Z]{2})[0-9] ]]; then
            echo "${BASH_REMATCH[1]}" | tr '[:upper:]' '[:lower:]'
        fi
    done | sort -u
}

test_server_latency() {
    local server_ip="$1"
    local timeout=5

    if [[ -z $server_ip ]]; then
        return 1
    fi

    local ping_result
    ping_result=$(ping -c 3 -W $timeout "$server_ip" 2> /dev/null | grep "avg" | awk -F '/' '{print $5}')

    if [[ -n $ping_result ]]; then
        echo "$ping_result"
        return 0
    else
        echo "999"
        return 1
    fi
}

# Issue #147: WCAG 2.1 Level AA accessibility - Screen reader detection
# Detects if accessibility mode should be enabled based on:
# 1. Explicit environment variables (VPN_ACCESSIBLE_MODE, SCREEN_READER_MODE)
# 2. GNOME screen reader settings (gsettings)
# 3. Active screen reader processes (Orca, Fenrir)
# 4. NO_COLOR preference
detect_accessibility_mode() {
    # 1. Explicit user preference (highest priority)
    if [[ -n ${VPN_ACCESSIBLE_MODE:-} ]] || [[ -n ${SCREEN_READER_MODE:-} ]]; then
        return 0
    fi

    # 2. GNOME accessibility settings (most reliable for GUI screen readers)
    if command -v gsettings &> /dev/null; then
        local screen_reader_enabled
        screen_reader_enabled=$(gsettings get org.gnome.desktop.a11y.applications screen-reader-enabled 2> /dev/null || echo "false")
        if [[ $screen_reader_enabled == "true" ]]; then
            return 0
        fi
    fi

    # 3. Active screen reader process detection
    if pgrep -x "orca" &> /dev/null || pgrep -x "fenrir" &> /dev/null; then
        return 0
    fi

    # 4. Console-based indicators (braille display)
    if [[ $TERM == "linux" ]] && command -v brltty &> /dev/null; then
        return 0 # Console with braille display
    fi

    # 5. NO_COLOR also implies text-only preference
    if [[ -n ${NO_COLOR:-} ]]; then
        return 0
    fi

    return 1
}

# Issue #147: WCAG 2.1 Level AA accessibility - Semantic status announcements
# Provides accessible connection status updates with semantic prefixes
# Args: $1 = stage (initializing|establishing|configuring|verifying|connected|failed)
#       $2 = message (human-readable status message)
announce_connection_status() {
    local stage="$1"
    local message="$2"

    if detect_accessibility_mode; then
        # Screen reader mode: semantic prefix + clear message
        case "$stage" in
            initializing)
                echo "[INFO] VPN connection starting: $message"
                ;;
            establishing | configuring | verifying)
                echo "[PROGRESS] VPN connection in progress: $message"
                ;;
            connected)
                echo "[SUCCESS] VPN connection established: $message"
                ;;
            failed)
                echo "[ERROR] VPN connection failed: $message"
                ;;
            *)
                echo "[INFO] VPN status: $message"
                ;;
        esac
    else
        # Visual mode: carriage return + spinner + message
        case "$stage" in
            connected)
                echo "" # New line for final state
                echo -e "\033[1;32m✓ $message\033[0m"
                ;;
            failed)
                echo "" # New line for final state
                echo -e "\033[1;31m✗ $message\033[0m"
                ;;
            *)
                echo -ne "\r  ⟳ $message                    "
                ;;
        esac
    fi
}

connect_to_profile() {
    local profile_path="$1"
    local max_attempts=3

    if [[ ! -f $profile_path ]]; then
        file_not_found_error "$COMP_VPN_CONNECTOR" "$profile_path" "Check filename spelling and ensure file exists in locations directory"
        return 1
    fi

    # Protocol detection - support both .ovpn and .conf
    local protocol
    protocol=$(detect_protocol "$profile_path")

    case "$protocol" in
        "openvpn")
            connect_openvpn_profile "$profile_path" "$max_attempts"
            ;;
        "wireguard")
            connect_wireguard_profile "$profile_path" "$max_attempts"
            ;;
        *)
            echo -e "\033[1;31mError: Unsupported protocol for $profile_path\033[0m"
            return 1
            ;;
    esac
}

check_vpn_processes() {
    # Check for any existing VPN connections (both OpenVPN and WireGuard)
    local openvpn_processes
    local wireguard_interfaces

    openvpn_processes=$(pgrep -f "openvpn.*config" 2> /dev/null | wc -l)
    wireguard_interfaces=$(wg show 2> /dev/null | grep -c "^interface:" 2> /dev/null || echo 0)

    # Ensure we have clean numeric values
    openvpn_processes=${openvpn_processes//[^0-9]/}
    wireguard_interfaces=${wireguard_interfaces//[^0-9]/}
    openvpn_processes=${openvpn_processes:-0}
    wireguard_interfaces=${wireguard_interfaces:-0}

    if [[ $openvpn_processes -gt 0 ]]; then
        echo -e "\033[1;31m⚠️  BLOCKED: $openvpn_processes OpenVPN process(es) already running!\033[0m"
        echo -e "\033[1;33m   Multiple VPN connections cause network conflicts and performance issues.\033[0m"
        echo -e "\033[1;33m   Run 'vpn cleanup' or 'vpn disconnect' first, then try again.\033[0m"
        return 1
    fi

    if [[ $wireguard_interfaces -gt 0 ]]; then
        echo -e "\033[1;31m⚠️  BLOCKED: $wireguard_interfaces WireGuard interface(s) already active!\033[0m"
        echo -e "\033[1;33m   Multiple VPN connections cause network conflicts and performance issues.\033[0m"
        echo -e "\033[1;33m   Run 'vpn disconnect' to close existing WireGuard connections first.\033[0m"
        return 1
    fi

    return 0
}

# Validates all prerequisites before attempting OpenVPN connection
# Returns: 0 on success, 1 on failure
validate_connection_prerequisites() {
    local profile_path="$1"

    if [[ ! -f $CREDENTIALS_FILE ]]; then
        file_not_found_error "$COMP_VPN_CONNECTOR" "$CREDENTIALS_FILE" "Create file with: echo -e 'username\\npassword' > $CREDENTIALS_FILE"
        return 1
    fi

    # Security: Comprehensive credential validation with HIGH-5 permission verification
    if ! validate_and_secure_credentials "$CREDENTIALS_FILE"; then
        log_message "SECURITY: Credentials file validation failed" "$CONNECTION_LOG"
        return 1
    fi

    # Security: Validate profile path before sudo operation (HIGH-2)
    if ! validate_profile_path "$profile_path" "$LOCATIONS_DIR"; then
        log_message "SECURITY: Profile path validation failed: $profile_path" "$CONNECTION_LOG"
        return 1
    fi

    # Security: Verify OpenVPN binary exists at trusted path (Issue #165, HIGH-severity)
    # Prevents privilege escalation via PATH manipulation
    if [[ ! -x $OPENVPN_BINARY ]]; then
        echo "ERROR: OpenVPN not found at trusted path: $OPENVPN_BINARY" >&2
        log_message "SECURITY: OpenVPN binary not found at trusted path" "$CONNECTION_LOG"
        return 1
    fi

    # Check for existing VPN processes (any protocol)
    if ! check_vpn_processes; then
        return 1
    fi

    return 0
}

# Initializes connection attempt with logging and cleanup
# Args: profile_path
# Returns: profile_name via echo
initialize_connection_attempt() {
    local profile_path="$1"
    local profile_name
    profile_name=$(basename "$profile_path" .ovpn)

    echo -e "\033[1;33mConnecting to OpenVPN profile: $profile_name...\033[0m"
    log_message "Attempting OpenVPN connection to $profile_name" "$CONNECTION_LOG"

    # Log to secure log file
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] Connection attempt started: $profile_name" >> "$CONNECTION_LOG" 2> /dev/null || true

    # Clean state before connecting
    "$VPN_DIR/vpn-manager" cleanup > /dev/null 2>&1
    sleep 2

    echo "$profile_name"
}

# Starts OpenVPN daemon process
# Args: profile_path
# Returns: 0 on daemon start (note: start != connected)
start_openvpn_daemon() {
    local profile_path="$1"

    # Clear previous log to avoid false positives
    sudo rm -f "$LOG_DIR/openvpn.log" 2> /dev/null || true
    sudo rm -f "/tmp/openvpn.log" 2> /dev/null || true # Fallback location cleanup

    # Start OpenVPN daemon without aggressive timeout
    # Security: Use hardcoded trusted path (Issue #165)
    sudo "$OPENVPN_BINARY" \
        --config "$profile_path" \
        --auth-user-pass "$CREDENTIALS_FILE" \
        --daemon \
        --writepid /var/run/openvpn.pid \
        --log "$LOG_DIR/openvpn.log" \
        --verb 3

    return 0
}

# Checks for authentication failures in OpenVPN logs
# Args: profile_name
# Returns: 0 if no auth failure, 1 if AUTH_FAILED detected (exits connection)
check_authentication_failure() {
    local profile_name="$1"

    # Check for authentication failures (both log locations)
    # openvpn may write to /tmp/openvpn.log as fallback if it can't write to LOG_DIR
    for log_location in "$LOG_DIR/openvpn.log" "/tmp/openvpn.log"; do
        if [[ -f $log_location ]] && sudo grep -q "AUTH_FAILED" "$log_location" 2> /dev/null; then
            # Issue #147: Use semantic announcement for accessibility
            announce_connection_status "failed" "Authentication failed - check credentials in $CREDENTIALS_FILE"
            log_message "Authentication failed for $profile_name - invalid credentials" "$CONNECTION_LOG"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] AUTH_FAILED: $profile_name" >> "$CONNECTION_LOG" 2> /dev/null || true
            notify_event "auth_failed" "$profile_name"
            sudo "$VPN_DIR/vpn-manager" cleanup > /dev/null 2>&1
            return 1
        fi
    done

    return 0
}

# Checks connection progress and updates stage
# Args: connection_stage_var, interval_count_var (variable names passed by reference)
# Returns: "connected" if established, "in_progress" if still connecting, "" if neither
check_connection_progress() {
    local connection_stage_var="$1"
    local interval_count_var="$2"
    local connection_stage="${!connection_stage_var}"
    local interval_count="${!interval_count_var}"

    # Check for TLS handshake completion (Peer Connection Initiated)
    for log_location in "$LOG_DIR/openvpn.log" "/tmp/openvpn.log"; do
        if [[ -f $log_location ]] && sudo grep -q "Peer Connection Initiated" "$log_location" 2> /dev/null; then
            if [[ $connection_stage != "configuring" ]]; then
                announce_connection_status "configuring" "Configuring tunnel"
                eval "$connection_stage_var='configuring'"
                eval "$interval_count_var=0"
                return 0
            fi
        fi
    done

    # Update to verifying stage if we've been configuring for a while
    if [[ $connection_stage == "configuring" && $interval_count -ge 2 ]]; then
        announce_connection_status "verifying" "Verifying connection"
        eval "$connection_stage_var='verifying'"
        eval "$interval_count_var=0"
    fi

    # Check if fully connected
    local status_check
    status_check=$(timeout 5 "$VPN_DIR/vpn-manager" status 2> /dev/null | grep "VPN Status:" | grep -q "CONNECTED" && echo "connected" || echo "not_connected")
    if [[ $status_check == "connected" ]]; then
        announce_connection_status "connected" "Connected"
        if ! detect_accessibility_mode; then
            echo ""
        fi
        echo "connected"
        return 0
    fi

    echo "in_progress"
    return 0
}

# Handles successful connection with logging and notification
# Args: profile_name, attempt, max_attempts
# Returns: 0
handle_connection_success() {
    local profile_name="$1"
    local attempt="$2"
    local max_attempts="$3"

    log_message "Successfully connected to OpenVPN $profile_name on attempt $attempt" "$CONNECTION_LOG"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] Connected successfully: $profile_name (attempt $attempt/$max_attempts)" >> "$CONNECTION_LOG" 2> /dev/null || true

    # Enable kill switch if requested (via environment variable or config)
    local kill_switch_script="$VPN_DIR/vpn-kill-switch"
    if [[ -x "$kill_switch_script" ]]; then
        if [[ "${VPN_KILL_SWITCH:-}" == "1" ]] || [[ "${VPN_KILL_SWITCH:-}" == "true" ]]; then
            echo "Enabling kill switch..."
            "$kill_switch_script" enable
        fi
    fi

    notify_event "connection_established" "$profile_name"
    pkill -RTMIN+4 dwmblocks 2> /dev/null || true

    return 0
}

# Cleans up failed OpenVPN processes after connection attempt fails
# Returns: 0
cleanup_failed_connection_processes() {
    local failed_processes
    failed_processes=$(pgrep -f "openvpn.*--config" 2> /dev/null | wc -l)
    if [[ $failed_processes -gt 1 ]]; then
        echo -e "\033[1;33m  Cleaning up $((failed_processes - 1)) failed process(es)\033[0m"
        # Kill all but the most recent process (keep the one that might succeed)
        pgrep -f "openvpn.*--config" 2> /dev/null | head -n -1 | xargs -r sudo kill 2> /dev/null || true
    fi

    return 0
}

# Monitors connection establishment with exponential backoff
# Args: profile_name
# Returns: 0 if connected, 1 if auth failed, 2 if timeout
# Issue #69: Progressive connection feedback
# Issue #147: WCAG 2.1 Level AA accessibility
# Issue #62: Exponential backoff for 40% faster establishment
monitor_connection_establishment_with_backoff() {
    local profile_name="$1"
    local -a BACKOFF_INTERVALS=(1 1 2 2 3 4 5 6)
    local connection_stage="initializing"
    local interval_count=0

    # Issue #147: Use semantic status announcements for accessibility
    announce_connection_status "initializing" "Initializing connection..."
    announce_connection_status "establishing" "Establishing connection"

    for interval in "${BACKOFF_INTERVALS[@]}"; do
        sleep "$interval"
        ((interval_count++))

        # Check for authentication failures
        if ! check_authentication_failure "$profile_name"; then
            return 1 # Auth failure
        fi

        # Check connection progress and status
        local progress_status
        progress_status=$(check_connection_progress connection_stage interval_count)

        if [[ $progress_status == "connected" ]]; then
            return 0 # Connection established
        fi

        # Show progress dots (visual mode only, Issue #147: accessibility)
        if ! detect_accessibility_mode; then
            local dot_count=$((interval_count % 4))
            if [[ $dot_count -le 3 ]]; then
                echo -n "."
            fi
        fi
    done

    return 2 # Timeout (all intervals exhausted)
}

connect_openvpn_profile() {
    local profile_path="$1"
    local max_attempts="$2"

    # Validate all prerequisites before proceeding
    if ! validate_connection_prerequisites "$profile_path"; then
        return 1
    fi

    # Initialize connection attempt and get profile name
    local profile_name
    profile_name=$(initialize_connection_attempt "$profile_path")

    for attempt in $(seq 1 "$max_attempts"); do
        echo "  Attempt $attempt of $max_attempts"

        # Start OpenVPN daemon
        start_openvpn_daemon "$profile_path"

        # Monitor connection with exponential backoff
        local monitor_result
        monitor_connection_establishment_with_backoff "$profile_name"
        monitor_result=$?

        if [[ $monitor_result -eq 0 ]]; then
            # Connection established
            handle_connection_success "$profile_name" "$attempt" "$max_attempts"
            return 0
        elif [[ $monitor_result -eq 1 ]]; then
            # Authentication failure (already handled by check_authentication_failure)
            return 1
        fi
        # monitor_result -eq 2: timeout, continue to next attempt

        echo ""
        echo -e "\033[1;33m  Connection attempt $attempt failed\033[0m"
        log_message "Connection attempt $attempt failed for OpenVPN $profile_name" "$CONNECTION_LOG"

        # Clean up failed processes after each attempt
        cleanup_failed_connection_processes

        if [[ $attempt -lt $max_attempts ]]; then
            echo "  Waiting before retry..."
            sleep 5
        fi
    done

    echo -e "\033[1;31m✗ Failed to connect to OpenVPN $profile_name after $max_attempts attempts\033[0m"
    log_message "Failed to connect to OpenVPN $profile_name after $max_attempts attempts" "$CONNECTION_LOG"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] Connection failed: $profile_name (all $max_attempts attempts exhausted)" >> "$CONNECTION_LOG" 2> /dev/null || true
    notify_event "connection_failed" "$profile_name"

    return 1
}

connect_wireguard_profile() {
    local profile_path="$1"
    local max_attempts="$2"

    # Validate WireGuard config
    if ! validate_wireguard_config "$profile_path"; then
        return 1
    fi

    # Check for existing VPN processes (any protocol)
    if ! check_vpn_processes; then
        return 1
    fi

    local interface_name
    interface_name=$(basename "$profile_path" .conf)

    # Note: Pre-cleanup removed due to network disruption issues

    echo -e "\033[1;33mConnecting to WireGuard profile: $interface_name...\033[0m"
    log_message "Attempting WireGuard connection to $interface_name" "$CONNECTION_LOG"

    for attempt in $(seq 1 "$max_attempts"); do
        echo "  Attempt $attempt of $max_attempts"

        # WireGuard connection attempt notification removed - using centralized system for result only

        # Simple WireGuard connection attempt (reverted to prevent network disruption)
        if sudo wg-quick up "$profile_path" > /dev/null 2>&1; then
            sleep 3

            # Verify connection is up
            if wg show "$interface_name" | grep -q "peer\|endpoint"; then
                echo -e "\033[1;32m✓ Successfully connected to WireGuard $interface_name\033[0m"
                log_message "Successfully connected to WireGuard $interface_name on attempt $attempt" "$CONNECTION_LOG"

                notify_event "connection_established" "$interface_name"
                pkill -RTMIN+4 dwmblocks 2> /dev/null || true

                return 0
            fi
        fi

        echo -e "\033[1;33m  WireGuard connection attempt $attempt failed\033[0m"
        log_message "WireGuard connection attempt $attempt failed for $interface_name" "$CONNECTION_LOG"

        # Cleanup failed attempt - use full path to config file
        sudo wg-quick down "$profile_path" > /dev/null 2>&1 || true

        if [[ $attempt -lt $max_attempts ]]; then
            echo "  Waiting before retry..."
            sleep 5
        fi
    done

    echo -e "\033[1;31m✗ Failed to connect to WireGuard $interface_name after $max_attempts attempts\033[0m"
    log_message "Failed to connect to WireGuard $interface_name after $max_attempts attempts" "$CONNECTION_LOG"
    notify_event "connection_failed" "$interface_name"

    return 1
}

connect_random() {
    local country_code="$1"

    local profiles
    profiles=$(find_profiles_by_country "$country_code")

    if [[ -z $profiles ]]; then
        if [[ -n $country_code ]]; then
            echo -e "\033[1;31mNo profiles found for country: $country_code\033[0m"
        else
            echo -e "\033[1;31mNo VPN profiles available\033[0m"
        fi
        return 1
    fi

    local profile_array=()
    while IFS= read -r profile; do
        profile_array+=("$profile")
    done <<< "$profiles"

    local random_index=$((RANDOM % ${#profile_array[@]}))
    local selected_profile="${profile_array[$random_index]}"

    echo -e "\033[1;36mSelected profile: $(basename "$selected_profile" .ovpn)\033[0m"

    connect_to_profile "$selected_profile"
}

load_performance_cache() {
    if [[ ! -f $PERFORMANCE_CACHE ]]; then
        return 1
    fi

    # Check if cache is older than 2 hours (7200 seconds)
    # Issue #73: Use detected stat format (25% faster - no fallback overhead)
    local cache_age
    # shellcheck disable=SC2086  # STAT_MTIME_FLAG must expand into flags (-c %Y or -f %m)
    cache_age=$(($(date +%s) - $(stat $STAT_MTIME_FLAG "$PERFORMANCE_CACHE" 2> /dev/null || echo 0)))

    if [[ $cache_age -gt 7200 ]]; then
        echo -e "\033[1;33mPerformance cache expired (${cache_age}s old), will refresh\033[0m"
        return 1
    fi

    echo -e "\033[1;36mUsing cached performance data (${cache_age}s old)\033[0m"
    return 0
}

save_performance_cache() {
    local cache_data="$1"

    echo "$cache_data" > "$PERFORMANCE_CACHE"
    log_message "Performance cache updated with $(echo "$cache_data" | wc -l) entries" "$CONNECTION_LOG"
}

# Resolve profile path from profile name (Issue #141: Extract duplicate logic)
# Args: $1 = profile_name, $2 = country_filter (optional)
# Returns: Full path to profile file, or empty string if not found
resolve_profile_path() {
    local profile_name="$1"
    local country_filter="${2:-}"

    # Validate input: reject empty profile names (prevents matching all profiles)
    [[ -z $profile_name ]] && return 1

    local profile_path

    # Primary resolution: match with extension
    if [[ -n $country_filter ]]; then
        # Flexible matching for country-filtered profiles (anywhere in path)
        profile_path=$(get_cached_profiles | grep -E "${profile_name}.*\.(ovpn|conf)$" | head -n1)
    else
        # Strict matching for non-country profiles (exact filename)
        profile_path=$(get_cached_profiles | grep -E "/${profile_name}\.(ovpn|conf)$" | head -n1)
    fi

    # Fallback: Partial match if primary resolution failed
    if [[ ! -f $profile_path ]]; then
        profile_path=$(get_cached_profiles | grep "$profile_name" | head -n1)
    fi

    # Return path (will be empty if no match found)
    echo "$profile_path"
}

get_cached_best_profile() {
    local country_filter="$1"

    # Use our comprehensive performance cache system
    local best_profile_name
    if best_profile_name=$("$VPN_DIR/best-vpn-profile" best "$country_filter" 2> /dev/null); then
        # Use helper function to resolve profile path (Issue #141)
        local profile_path
        profile_path=$(resolve_profile_path "$best_profile_name" "$country_filter")

        if [[ -f $profile_path ]]; then
            echo -e "\033[1;32mCached best server: $best_profile_name\033[0m"
            echo "$profile_path"
            return 0
        else
            echo -e "\033[1;33mCached profile path not found for: $best_profile_name\033[0m"
        fi
    fi

    echo -e "\033[1;33mNo suitable cached profile found\033[0m"
    return 1
}

test_and_cache_performance() {
    local country_filter="$1"
    # Parameter max_tests (${2:-8}) reserved for future performance testing expansion

    echo -e "\033[1;36m╔════════════════════════════════════════╗\033[0m"
    echo -e "\033[1;36m║       Testing VPN Server Performance   ║\033[0m"
    echo -e "\033[1;36m╚════════════════════════════════════════╝\033[0m"
    echo

    if ! check_internet; then
        return 1
    fi

    # Use our comprehensive performance testing engine
    local best_profile_name
    if best_profile_name=$("$VPN_DIR/best-vpn-profile" fresh "$country_filter" 2> /dev/null); then
        # Use helper function to resolve profile path (Issue #141)
        local profile_path
        profile_path=$(resolve_profile_path "$best_profile_name" "$country_filter")

        if [[ -f $profile_path ]]; then
            echo
            echo -e "\033[1;32mBest server selected: $best_profile_name\033[0m"
            echo "$profile_path"
            return 0
        else
            echo -e "\033[1;33mProfile path not found for: $best_profile_name\033[0m"
        fi
    fi

    echo -e "\033[1;31mNo suitable server found through performance testing\033[0m"
    return 1
}

best_server_connect() {
    local use_cache="$1"
    local country_filter="$2"
    local profile_path

    # Fast mode: use cached profile if available
    if [[ $use_cache == "fast" ]]; then
        local cached_profile
        if cached_profile=$(get_cached_best_profile "$country_filter" 2> /dev/null); then
            echo -e "\033[1;36mUsing cached performance data for fast connection\033[0m"

            # Resolve profile path from cached profile name
            profile_path=$(resolve_profile_path "$cached_profile" "$country_filter")

            if [[ -f $profile_path ]]; then
                echo -e "\033[1;32mCached best server: $cached_profile\033[0m"
                connect_to_profile "$profile_path"
                return $?
            else
                echo -e "\033[1;33mCached profile not found, running full performance test\033[0m"
            fi
        fi
    fi

    # Full mode: run performance testing to find best server
    local best_profile_name
    if best_profile_name=$("$VPN_DIR/best-vpn-profile" best "$country_filter" 2> /dev/null); then
        # Resolve profile path
        profile_path=$(resolve_profile_path "$best_profile_name" "$country_filter")

        if [[ -f $profile_path ]]; then
            echo
            echo -e "\033[1;32mBest server selected: $best_profile_name\033[0m"
            connect_to_profile "$profile_path"
            return $?
        else
            echo -e "\033[1;33mProfile path not found for: $best_profile_name\033[0m"
            return 1
        fi
    fi

    echo -e "\033[1;31mNo suitable server found through performance testing\033[0m"
    return 1
}

secure_core_connect() {
    echo -e "\033[1;36mSecure core server selection\033[0m"
    # Secure core provides enhanced privacy through double-hop routing
    local secure_profiles
    secure_profiles=$(detect_secure_core_profiles)

    if [[ -z $secure_profiles ]]; then
        echo -e "\033[1;33mNo secure core profiles detected, using regular profiles\033[0m"
        connect_random
    else
        echo -e "\033[1;32mFound $(echo "$secure_profiles" | wc -l) secure core profiles\033[0m"
        local profile_array=()
        while IFS= read -r profile; do
            profile_array+=("$profile")
        done <<< "$secure_profiles"

        local random_index=$((RANDOM % ${#profile_array[@]}))
        local selected_profile="${profile_array[$random_index]}"

        echo -e "\033[1;36mSelected secure core: $(basename "$selected_profile" .ovpn)\033[0m"
        connect_to_profile "$selected_profile"
    fi
}

connect_custom_profile() {
    local profile_path="$1"

    if [[ -z $profile_path ]]; then
        echo -e "\033[1;31mError: Custom profile path not provided\033[0m"
        echo "Usage: vpn custom <profile_path>"
        return 1
    fi

    # Validate file existence
    if [[ ! -f $profile_path ]]; then
        echo -e "\033[1;31mError: Custom profile not found: $profile_path\033[0m"
        return 1
    fi

    # Validate profile format - support both .ovpn and .conf
    local protocol
    protocol=$(detect_protocol "$profile_path")

    case "$protocol" in
        "openvpn")
            # Basic validation of OpenVPN config content
            if ! grep -q "^client$\|^remote\|^dev tun\|^dev tap" "$profile_path"; then
                echo -e "\033[1;31mError: Invalid .ovpn file format or missing required OpenVPN directives\033[0m"
                return 1
            fi
            ;;
        "wireguard")
            # Validate WireGuard config
            if ! validate_wireguard_config "$profile_path"; then
                return 1
            fi
            ;;
        *)
            echo -e "\033[1;31mError: Invalid profile format. Only .ovpn and .conf files are supported\033[0m"
            return 1
            ;;
    esac

    echo -e "\033[1;36mConnecting to custom profile: $(basename "$profile_path")\033[0m"
    connect_to_profile "$profile_path"
}

# Main execution guard - only run if executed directly, not sourced
if [[ ${BASH_SOURCE[0]} == "${0}" ]]; then

    case "${1:-}" in
        "connect" | "c")
            if ! check_dependencies; then
                exit 1
            fi

            if ! acquire_lock; then
                exit 1
            fi

            connect_random "${2:-}"
            ;;
        "best" | "b")
            if ! check_dependencies; then
                exit 1
            fi

            if ! acquire_lock; then
                exit 1
            fi

            # For TDD GREEN phase: make best command actually perform connection
            echo -e "\033[1;36mFinding best server and connecting...\033[0m"
            best_server_connect "full" "${2:-}"
            ;;
        "fast" | "f")
            if ! check_dependencies; then
                exit 1
            fi

            if ! acquire_lock; then
                exit 1
            fi

            echo -e "\033[1;33mFast connect mode (using cached results if available)\033[0m"
            best_server_connect "fast" "${2:-}"
            ;;
        "secure")
            if ! check_dependencies; then
                exit 1
            fi

            if ! acquire_lock; then
                exit 1
            fi

            secure_core_connect
            ;;
        "custom")
            if ! check_dependencies; then
                exit 1
            fi

            if ! acquire_lock; then
                exit 1
            fi

            connect_custom_profile "${2:-}"
            ;;
        "interactive" | "i")
            if ! check_dependencies; then
                exit 1
            fi

            if ! acquire_lock; then
                exit 1
            fi

            interactive_profile_selection "${2:-}"
            ;;
        "countries")
            echo -e "\033[1;36mAvailable countries in profiles:\033[0m"
            get_available_countries | while read -r country; do
                count=$(find_profiles_by_country "$country" | wc -l)
                printf "  %-3s (%d profiles)\n" "${country^^}" "$count"
            done
            ;;
        "list" | "l")
            if [[ ${2:-} == "detailed" ]]; then
                list_profiles "${3:-}" "detailed"
            else
                list_profiles "${2:-}"
            fi
            ;;
        "cache")
            case "${2:-}" in
                "clear")
                    if [[ -f $PERFORMANCE_CACHE ]]; then
                        rm -f "$PERFORMANCE_CACHE"
                        echo -e "\033[1;32mPerformance cache cleared\033[0m"
                    else
                        echo -e "\033[1;33mNo cache file to clear\033[0m"
                    fi
                    ;;
                "info")
                    if [[ -f $PERFORMANCE_CACHE ]]; then
                        # shellcheck disable=SC2086  # STAT_MTIME_FLAG must expand into flags
                        cache_age=$(($(date +%s) - $(stat $STAT_MTIME_FLAG "$PERFORMANCE_CACHE" 2> /dev/null || echo 0)))
                        cache_size=$(du -h "$PERFORMANCE_CACHE" 2> /dev/null | cut -f1)
                        cache_entries=$(wc -l < "$PERFORMANCE_CACHE" 2> /dev/null)

                        echo -e "\033[1;36mPerformance Cache Information:\033[0m"
                        echo "  File: $PERFORMANCE_CACHE"
                        echo "  Age: ${cache_age}s ($((cache_age / 60))m $((cache_age % 60))s)"
                        echo "  Size: $cache_size"
                        echo "  Entries: $cache_entries"

                        if [[ $cache_age -gt 7200 ]]; then
                            echo -e "  \033[1;33mStatus: Expired (>2 hours)\033[0m"
                        else
                            echo -e "  \033[1;32mStatus: Valid\033[0m"
                        fi
                    else
                        echo -e "\033[1;33mNo performance cache found\033[0m"
                    fi
                    ;;
                *)
                    echo "Cache commands: clear, info"
                    ;;
            esac
            ;;
        "test" | "t")
            if ! check_dependencies; then
                echo -e "\033[1;31mDependency check failed\033[0m"
                exit 1
            fi

            if ! check_internet; then
                echo -e "\033[1;31mInternet connectivity test failed\033[0m"
                exit 1
            fi

            if [[ ! -f $CREDENTIALS_FILE ]]; then
                echo -e "\033[1;31mCredentials file missing: $CREDENTIALS_FILE\033[0m"
                exit 1
            fi

            if ! list_profiles > /dev/null; then
                echo -e "\033[1;31mNo VPN profiles available\033[0m"
                exit 1
            fi

            echo -e "\033[1;32m✓ All VPN connector tests passed\033[0m"
            ;;
        *)
            echo "VPN Connector - Advanced Connection Management (Phase 3)"
            echo "Usage: $0 {connect|best|fast|secure|custom|interactive|list|countries|cache|test} [options]"
            echo ""
            echo "Connection Commands:"
            echo "  connect [country]     - Connect to random server (optional country filter)"
            echo "  best [country]        - Connect to best performing server (full test)"
            echo "  fast [country]        - Quick connect using cached performance data"
            echo "  secure                - Connect to secure core server"
            echo "  custom <profile>      - Connect using custom profile path"
            echo "  interactive [country] - Interactive profile selection menu"
            echo ""
            echo "Information Commands:"
            echo "  list [country]        - List available VPN profiles"
            echo "  list detailed [country] - Detailed profile listing with server IPs"
            echo "  countries             - Show available countries and profile counts"
            echo ""
            echo "Cache Management:"
            echo "  cache info           - Show performance cache information"
            echo "  cache clear          - Clear performance cache"
            echo ""
            echo "Utility Commands:"
            echo "  test                 - Test VPN connector functionality"
            echo ""
            echo "Examples:"
            echo "  $0 connect se        - Connect to Swedish server"
            echo "  $0 best nl           - Find and connect to best Netherlands server"
            echo "  $0 fast              - Fast connect to best cached server"
            echo "  $0 interactive se    - Choose from Swedish servers interactively"
            echo "  $0 list detailed nl  - Show detailed Netherlands server info"
            echo "  $0 secure            - Connect to secure core server"
            exit 1
            ;;
    esac

fi # End of main execution guard
