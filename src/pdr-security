#!/bin/bash
# ABOUTME: Security validation and sanitization library for PDR system
# ABOUTME: Provides path traversal prevention, input sanitization, and secure file operations

# Source existing error handling
VPN_DIR="$(dirname "$(realpath "$0")")"
if [[ -f "$VPN_DIR/vpn-error-handler" ]]; then
    source "$VPN_DIR/vpn-error-handler"
else
    # Fallback error function for testing
    vpn_error() {
        echo "[$1] $2: $3 - $4" >&2
        return 1
    }
fi

# PDR-specific security constants (with guards to prevent redefinition)
if [[ -z "$PDR_COMPONENT" ]]; then
    readonly PDR_COMPONENT="PDR-SECURITY"
    readonly ERR_SECURITY="SECURITY"
    readonly ERR_INPUT="INPUT_VALIDATION"
fi

# PDR security error templates
declare -A PDR_ERROR_TEMPLATES=(
    ["PATH_TRAVERSAL"]="Path traversal attempt detected"
    ["SHELL_INJECTION"]="Shell injection attempt blocked"
    ["INPUT_TOO_LARGE"]="Input exceeds maximum allowed size"
    ["INVALID_CHARACTERS"]="Input contains invalid or dangerous characters"
    ["RACE_CONDITION"]="File operation race condition detected"
    ["PERMISSION_VIOLATION"]="File permission validation failed"
)

# PDR security actions
declare -A PDR_SECURITY_ACTIONS=(
    ["PATH_TRAVERSAL"]="Use only alphanumeric characters, hyphens, and underscores in PDR names"
    ["SHELL_INJECTION"]="Avoid shell metacharacters in PDR content and names"
    ["INPUT_TOO_LARGE"]="Reduce content size to under 10MB limit"
    ["INVALID_CHARACTERS"]="Use standard ASCII characters only"
    ["RACE_CONDITION"]="Wait for current PDR operation to complete before starting new one"
    ["PERMISSION_VIOLATION"]="Check file permissions and ownership in PDR directory"
)

# Critical security settings (with guards)
if [[ -z "$PDR_MAX_SIZE" ]]; then
    readonly PDR_MAX_SIZE=10485760  # 10MB limit
    readonly PDR_MAX_NAME_LENGTH=50
    readonly PDR_NAME_PATTERN='^[a-zA-Z0-9][a-zA-Z0-9_-]{0,49}$'
fi

# Secure PDR directory validation
validate_pdr_directory() {
    local pdr_dir="${1:-$PROJECT_ROOT/docs/pdr}"

    # Resolve to canonical path
    local canonical_dir
    canonical_dir=$(realpath "$pdr_dir" 2>/dev/null) || {
        vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "${PDR_ERROR_TEMPLATES[PERMISSION_VIOLATION]}" \
            "Cannot resolve PDR directory: $pdr_dir" \
            "Ensure PDR directory exists and is accessible"
        return 1
    }

    # Ensure directory is within project bounds
    local project_root
    project_root=$(realpath "$PROJECT_ROOT" 2>/dev/null) || {
        vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "Cannot resolve project root directory" \
            "PROJECT_ROOT may be unset or invalid" \
            "Set PROJECT_ROOT environment variable"
        return 1
    }

    [[ "$canonical_dir" == "$project_root"/* ]] || {
        vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "${PDR_ERROR_TEMPLATES[PATH_TRAVERSAL]}" \
            "PDR directory outside project bounds: $canonical_dir" \
            "${PDR_SECURITY_ACTIONS[PATH_TRAVERSAL]}"
        return 1
    }

    echo "$canonical_dir"
    return 0
}

# Critical: Path traversal prevention for PDR names
validate_pdr_name() {
    local pdr_name="$1"

    # Input validation
    [[ -n "$pdr_name" ]] || {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_INPUT" \
            "PDR name cannot be empty" \
            "validate_pdr_name called with empty parameter" \
            "Provide a valid PDR name"
        return 1
    }

    # Length validation
    [[ ${#pdr_name} -le $PDR_MAX_NAME_LENGTH ]] || {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_INPUT" \
            "${PDR_ERROR_TEMPLATES[INPUT_TOO_LARGE]}" \
            "PDR name length: ${#pdr_name} characters (max: $PDR_MAX_NAME_LENGTH)" \
            "Use shorter, descriptive PDR name"
        return 1
    }

    # Pattern validation - prevent path traversal and shell injection
    [[ "$pdr_name" =~ $PDR_NAME_PATTERN ]] || {
        vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "${PDR_ERROR_TEMPLATES[INVALID_CHARACTERS]}" \
            "PDR name contains invalid characters: $pdr_name" \
            "${PDR_SECURITY_ACTIONS[PATH_TRAVERSAL]}"
        return 1
    }

    # Explicit path traversal detection
    [[ "$pdr_name" =~ \.\./|\.\.\\ ]] && {
        vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "${PDR_ERROR_TEMPLATES[PATH_TRAVERSAL]}" \
            "Path traversal pattern detected: $pdr_name" \
            "${PDR_SECURITY_ACTIONS[PATH_TRAVERSAL]}"
        return 1
    }

    # Shell metacharacter detection
    local dangerous_chars='[$`()|;&<>{}*?!]'
    [[ "$pdr_name" =~ $dangerous_chars ]] && {
        vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "${PDR_ERROR_TEMPLATES[SHELL_INJECTION]}" \
            "Shell metacharacters detected in PDR name: $pdr_name" \
            "${PDR_SECURITY_ACTIONS[SHELL_INJECTION]}"
        return 1
    }

    return 0
}

# Critical: Secure path construction and validation
validate_pdr_path() {
    local pdr_name="$1"
    local pdr_dir="${2:-}"

    # Validate PDR name first
    validate_pdr_name "$pdr_name" || return 1

    # Get validated PDR directory
    if [[ -n "$pdr_dir" ]]; then
        pdr_dir=$(validate_pdr_directory "$pdr_dir") || return 1
    else
        pdr_dir=$(validate_pdr_directory) || return 1
    fi

    # Construct and validate final path
    local pdr_file="$pdr_dir/$pdr_name.md"
    local resolved_path
    resolved_path=$(realpath -m "$pdr_file" 2>/dev/null) || {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "${PDR_ERROR_TEMPLATES[PERMISSION_VIOLATION]}" \
            "Cannot resolve PDR file path: $pdr_file" \
            "Check PDR directory permissions and filesystem status"
        return 1
    }

    # Final boundary check
    [[ "$resolved_path" == "$pdr_dir"/* ]] || {
        vpn_error "$ERROR_CRITICAL" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "${PDR_ERROR_TEMPLATES[PATH_TRAVERSAL]}" \
            "Resolved path escapes PDR directory: $resolved_path" \
            "${PDR_SECURITY_ACTIONS[PATH_TRAVERSAL]}"
        return 1
    }

    echo "$resolved_path"
    return 0
}

# Critical: Input sanitization for PDR content
sanitize_pdr_content() {
    local content="$1"
    local max_size="${2:-$PDR_MAX_SIZE}"

    # Size validation
    local content_size=${#content}
    [[ $content_size -le $max_size ]] || {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_INPUT" \
            "${PDR_ERROR_TEMPLATES[INPUT_TOO_LARGE]}" \
            "Content size: $content_size bytes (max: $max_size)" \
            "${PDR_SECURITY_ACTIONS[INPUT_TOO_LARGE]}"
        return 1
    }

    # Remove dangerous HTML/JavaScript patterns
    content=$(echo "$content" | sed -E \
        -e 's/<script[^>]*>.*<\/script>//gi' \
        -e 's/<iframe[^>]*>.*<\/iframe>//gi' \
        -e 's/<object[^>]*>.*<\/object>//gi' \
        -e 's/<embed[^>]*>.*<\/embed>//gi' \
        -e 's/javascript://gi' \
        -e 's/data:text\/html/data-text-html/gi' \
        -e 's/vbscript://gi' \
        -e 's/onload=//gi' \
        -e 's/onclick=//gi' \
        -e 's/onmouseover=//gi' \
        -e 's/onerror=//gi')

    # Remove shell injection patterns
    content=$(echo "$content" | sed -E \
        -e 's/\$\([^)]*\)//g' \
        -e 's/`[^`]*`//g' \
        -e 's/\$\{[^}]*\}//g')

    # Remove format string specifiers
    content=$(echo "$content" | sed 's/%[sdxnc]//g')

    echo "$content"
    return 0
}

# Critical: Secure file creation with proper permissions
secure_pdr_file_create() {
    local pdr_file="$1"
    local content="$2"

    # Validate path first
    local parent_dir
    parent_dir=$(dirname "$pdr_file")
    [[ -d "$parent_dir" ]] || {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_FILE_ACCESS" \
            "PDR parent directory does not exist" \
            "Directory: $parent_dir" \
            "Create PDR directory structure first"
        return 1
    }

    # Set secure umask before file creation
    local old_umask
    old_umask=$(umask)
    umask 077  # Restrictive permissions during creation

    # Create file securely
    {
        touch "$pdr_file" || {
            umask "$old_umask"
            vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_FILE_ACCESS" \
                "${PDR_ERROR_TEMPLATES[PERMISSION_VIOLATION]}" \
                "Cannot create PDR file: $pdr_file" \
                "Check directory permissions and disk space"
            return 1
        }

        # Set secure permissions
        chmod 644 "$pdr_file" || {
            umask "$old_umask"
            rm -f "$pdr_file"  # Clean up on permission failure
            vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PERMISSION" \
                "${PDR_ERROR_TEMPLATES[PERMISSION_VIOLATION]}" \
                "Cannot set PDR file permissions: $pdr_file" \
                "Check file ownership and ACL settings"
            return 1
        }

        # Write content securely
        echo "$content" > "$pdr_file" || {
            umask "$old_umask"
            rm -f "$pdr_file"  # Clean up on write failure
            vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_FILE_ACCESS" \
                "Cannot write PDR content to file" \
                "File: $pdr_file" \
                "Check disk space and file permissions"
            return 1
        }

    }

    # Restore original umask
    umask "$old_umask"
    return 0
}

# Critical: File locking mechanism for race condition prevention
# PDR lock directory (with guard)
if [[ -z "$PDR_LOCK_DIR" ]]; then
    PDR_LOCK_DIR="/tmp/pdr_locks_$(id -u)"
fi

acquire_pdr_lock() {
    local lock_name="$1"
    local timeout="${2:-30}"
    local count=0

    # Create lock directory securely
    [[ -d "$PDR_LOCK_DIR" ]] || {
        mkdir -p "$PDR_LOCK_DIR" || {
            vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PERMISSION" \
                "Cannot create PDR lock directory" \
                "Directory: $PDR_LOCK_DIR" \
                "Check /tmp permissions and available space"
            return 1
        }
        chmod 700 "$PDR_LOCK_DIR"
    }

    local lock_file="$PDR_LOCK_DIR/$lock_name.lock"

    # Attempt to acquire lock with timeout
    while [[ $count -lt $timeout ]]; do
        if (set -C; echo $$ > "$lock_file") 2>/dev/null; then
            return 0  # Lock acquired successfully
        fi

        # Check if lock holder is still alive
        if [[ -f "$lock_file" ]]; then
            local lock_pid
            lock_pid=$(cat "$lock_file" 2>/dev/null)
            if [[ -n "$lock_pid" ]] && ! kill -0 "$lock_pid" 2>/dev/null; then
                # Stale lock, remove it
                rm -f "$lock_file" 2>/dev/null
                continue
            fi
        fi

        sleep 1
        ((count++))
    done

    vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PROCESS" \
        "${PDR_ERROR_TEMPLATES[RACE_CONDITION]}" \
        "Failed to acquire lock after ${timeout}s: $lock_name" \
        "${PDR_SECURITY_ACTIONS[RACE_CONDITION]}"
    return 1
}

release_pdr_lock() {
    local lock_name="$1"
    local lock_file="$PDR_LOCK_DIR/$lock_name.lock"

    [[ -f "$lock_file" ]] && rm -f "$lock_file"
}

# Critical: Safe git operations for PDR system
safe_git_add_pdr() {
    local pdr_file="$1"

    # Validate file exists and is within project
    [[ -f "$pdr_file" ]] || {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_FILE_ACCESS" \
            "PDR file not found for git add" \
            "File: $pdr_file" \
            "Ensure PDR file was created successfully"
        return 1
    }

    # Use array to prevent shell injection
    local git_add_cmd=(git add "$pdr_file")

    "${git_add_cmd[@]}" || {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PROCESS" \
            "Git add operation failed for PDR" \
            "File: $pdr_file" \
            "Check git repository status and file permissions"
        return 1
    }

    return 0
}

safe_git_commit_pdr() {
    local pdr_name="$1"
    local message="$2"

    # Sanitize commit message
    message=$(sanitize_commit_message "$message")

    # Use array for safe parameter passing
    local git_commit_cmd=(git commit -m "$message")

    "${git_commit_cmd[@]}" || {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_PROCESS" \
            "Git commit operation failed for PDR" \
            "PDR: $pdr_name" \
            "Check git configuration and repository status"
        return 1
    }

    return 0
}

# Critical: Commit message sanitization
sanitize_commit_message() {
    local message="$1"

    # Remove potentially dangerous characters
    message=$(echo "$message" | tr -d '\000-\037\177')  # Remove control characters
    message=$(echo "$message" | sed 's/[`$(){}|;&<>]//g')  # Remove shell metacharacters

    # Limit message length
    if [[ ${#message} -gt 100 ]]; then
        message="${message:0:97}..."
    fi

    # Ensure non-empty message
    [[ -n "$message" ]] || message="PDR update"

    echo "$message"
}

# Input validation for search queries
validate_search_query() {
    local query="$1"
    local max_length="${2:-200}"

    # Length validation
    [[ ${#query} -le $max_length ]] || {
        vpn_error "$ERROR_MEDIUM" "$PDR_COMPONENT" "$ERR_INPUT" \
            "${PDR_ERROR_TEMPLATES[INPUT_TOO_LARGE]}" \
            "Search query length: ${#query} characters (max: $max_length)" \
            "Use shorter, more specific search terms"
        return 1
    }

    # Prevent regex DoS attacks
    local complexity_patterns='(\*{3,}|\+{3,}|\.{10,}|\?{5,})'
    [[ "$query" =~ $complexity_patterns ]] && {
        vpn_error "$ERROR_HIGH" "$PDR_COMPONENT" "$ERR_SECURITY" \
            "Search query contains complex patterns that could cause performance issues" \
            "Pattern detected in: $query" \
            "Use simpler search terms without repeated wildcards"
        return 1
    }

    return 0
}

# Critical security test function
test_pdr_security() {
    echo "=== PDR Security Validation Tests ==="
    local test_count=0
    local passed_count=0

    # Test 1: Path traversal prevention
    ((test_count++))
    if ! validate_pdr_name "../../../etc/passwd" >/dev/null 2>&1; then
        echo "✅ Path traversal prevention working"
        ((passed_count++))
    else
        echo "❌ Path traversal prevention failed"
    fi

    # Test 2: Shell injection prevention
    ((test_count++))
    if ! validate_pdr_name "test; rm -rf /" >/dev/null 2>&1; then
        echo "✅ Shell injection prevention working"
        ((passed_count++))
    else
        echo "❌ Shell injection prevention failed"
    fi

    # Test 3: Content sanitization
    ((test_count++))
    local malicious_content='<script>alert("xss")</script>$(rm -rf /)'
    local sanitized_content
    sanitized_content=$(sanitize_pdr_content "$malicious_content")
    if [[ "$sanitized_content" != *"<script>"* ]] && [[ "$sanitized_content" != *'$(rm'* ]]; then
        echo "✅ Content sanitization working"
        ((passed_count++))
    else
        echo "❌ Content sanitization failed"
    fi

    # Test 4: File permissions
    ((test_count++))
    local test_file="/tmp/pdr_test_$(date +%s).md"
    if secure_pdr_file_create "$test_file" "test content" >/dev/null 2>&1; then
        local perms
        perms=$(stat -c %a "$test_file" 2>/dev/null)
        rm -f "$test_file"
        if [[ "$perms" == "644" ]]; then
            echo "✅ Secure file permissions working"
            ((passed_count++))
        else
            echo "❌ File permissions incorrect: $perms"
        fi
    else
        echo "❌ Secure file creation failed"
    fi

    echo "=== Security Test Results: $passed_count/$test_count passed ==="
    return $((test_count - passed_count))
}

# Ensure this is being sourced, not executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "PDR Security Library - Run security tests"
    test_pdr_security
    exit $?
fi
