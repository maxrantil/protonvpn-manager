#!/bin/bash
# ABOUTME: Enterprise-grade VPN health monitoring system with automatic recovery
# ABOUTME: Proactive monitoring, alerting, and service recovery following security patterns

set -euo pipefail

# Security: Follow established patterns from notification-manager and status-dashboard
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Configuration integration (following config-manager patterns)
readonly CONFIG_DIR="${VPN_CONFIG_DIR:-/etc/protonvpn}"
readonly CONFIG_FILE="$CONFIG_DIR/health-monitor.conf"
readonly SECURE_CONFIG_MANAGER="$SCRIPT_DIR/config-manager"
readonly NOTIFICATION_MANAGER="$SCRIPT_DIR/notification-manager"
readonly SECURE_DB_MANAGER="$SCRIPT_DIR/secure-database-manager"
readonly STATUS_DASHBOARD="$SCRIPT_DIR/status-dashboard"
readonly AUDIT_LOG_PROTECTOR="$SCRIPT_DIR/audit-log-protector"

# Default configuration values (following agent recommendations)
readonly DEFAULT_CHECK_INTERVAL=30
readonly DEFAULT_RECOVERY_ENABLED=true
readonly DEFAULT_MAX_RECOVERY_ATTEMPTS=3
readonly DEFAULT_MEMORY_WARNING_MB=20
readonly DEFAULT_MEMORY_CRITICAL_MB=23
readonly DEFAULT_CPU_WARNING_PERCENT=80
readonly DEFAULT_CPU_CRITICAL_PERCENT=95

# Runtime state files
readonly HEALTH_STATE_DIR="/var/lib/protonvpn/health"
readonly RECOVERY_ATTEMPTS_FILE="$HEALTH_STATE_DIR/recovery_attempts"
readonly LAST_CHECK_FILE="$HEALTH_STATE_DIR/last_check"
readonly DAEMON_PID_FILE="/var/run/protonvpn-health-monitor.pid"

# Load health monitor configuration
load_health_config() {
    local check_interval="$DEFAULT_CHECK_INTERVAL"
    local recovery_enabled="$DEFAULT_RECOVERY_ENABLED"
    local max_recovery_attempts="$DEFAULT_MAX_RECOVERY_ATTEMPTS"
    local memory_warning_mb="$DEFAULT_MEMORY_WARNING_MB"
    local memory_critical_mb="$DEFAULT_MEMORY_CRITICAL_MB"
    local cpu_warning_percent="$DEFAULT_CPU_WARNING_PERCENT"
    local cpu_critical_percent="$DEFAULT_CPU_CRITICAL_PERCENT"

    # Use config-manager if available (following existing pattern)
    if [[ -x "$SECURE_CONFIG_MANAGER" && -f "$CONFIG_FILE" ]]; then
        check_interval=$("$SECURE_CONFIG_MANAGER" get "$CONFIG_FILE" "health_monitor.check_interval" 2>/dev/null || echo "$DEFAULT_CHECK_INTERVAL")
        recovery_enabled=$("$SECURE_CONFIG_MANAGER" get "$CONFIG_FILE" "health_monitor.recovery_enabled" 2>/dev/null || echo "$DEFAULT_RECOVERY_ENABLED")
        max_recovery_attempts=$("$SECURE_CONFIG_MANAGER" get "$CONFIG_FILE" "health_monitor.max_recovery_attempts" 2>/dev/null || echo "$DEFAULT_MAX_RECOVERY_ATTEMPTS")
        memory_warning_mb=$("$SECURE_CONFIG_MANAGER" get "$CONFIG_FILE" "health_monitor.thresholds.memory_warning_mb" 2>/dev/null || echo "$DEFAULT_MEMORY_WARNING_MB")
        memory_critical_mb=$("$SECURE_CONFIG_MANAGER" get "$CONFIG_FILE" "health_monitor.thresholds.memory_critical_mb" 2>/dev/null || echo "$DEFAULT_MEMORY_CRITICAL_MB")
        cpu_warning_percent=$("$SECURE_CONFIG_MANAGER" get "$CONFIG_FILE" "health_monitor.thresholds.cpu_warning_percent" 2>/dev/null || echo "$DEFAULT_CPU_WARNING_PERCENT")
        cpu_critical_percent=$("$SECURE_CONFIG_MANAGER" get "$CONFIG_FILE" "health_monitor.thresholds.cpu_critical_percent" 2>/dev/null || echo "$DEFAULT_CPU_CRITICAL_PERCENT")
    fi

    export HEALTH_CHECK_INTERVAL="$check_interval"
    export HEALTH_RECOVERY_ENABLED="$recovery_enabled"
    export HEALTH_MAX_RECOVERY_ATTEMPTS="$max_recovery_attempts"
    export HEALTH_MEMORY_WARNING_MB="$memory_warning_mb"
    export HEALTH_MEMORY_CRITICAL_MB="$memory_critical_mb"
    export HEALTH_CPU_WARNING_PERCENT="$cpu_warning_percent"
    export HEALTH_CPU_CRITICAL_PERCENT="$cpu_critical_percent"
}

# Audit logging integration (following established patterns)
log_health_event() {
    local event_type="$1"
    local component="$2"
    local details="$3"
    local user="${SUDO_USER:-$USER}"
    local timestamp="$(date '+%Y-%m-%d %H:%M:%S')"

    # Use audit-log-protector if available
    if [[ -x "$AUDIT_LOG_PROTECTOR" ]]; then
        echo "[$timestamp] COMPONENT=health-monitor USER=$user EVENT=$event_type COMPONENT_CHECKED=$component DETAILS=$details" | \
            "$AUDIT_LOG_PROTECTOR" protect >/dev/null 2>&1 || true
    fi
}

# Security sanitization (following notification-manager patterns)
sanitize_health_output() {
    local content="$1"
    local max_length="${2:-500}"

    # Remove potentially sensitive information
    content=$(echo "$content" | sed -E 's/(password|key|secret|token)=[^[:space:]]*/\1=***REDACTED***/gi')
    content=$(echo "$content" | sed -E 's|(/root|/home/[^/]*/\.ssh|/etc/shadow)[^[:space:]]*|\*\*\*REDACTED\*\*\*|g')

    # Limit length
    if [[ ${#content} -gt $max_length ]]; then
        content="${content:0:$max_length}..."
    fi

    echo "$content"
}

# Initialize health monitoring state directory
init_health_state() {
    if [[ ! -d "$HEALTH_STATE_DIR" ]]; then
        mkdir -p "$HEALTH_STATE_DIR" 2>/dev/null || true
        chmod 750 "$HEALTH_STATE_DIR" 2>/dev/null || true
    fi
}

# Check VPN service health (comprehensive)
check_service_health() {
    local service_status="unknown"
    local health_score=0
    local issues=()

    # Check systemd service status
    if systemctl is-active protonvpn-updater.service >/dev/null 2>&1; then
        service_status="active"
        ((health_score += 25))
    elif systemctl is-active protonvpn-service >/dev/null 2>&1; then
        service_status="active"
        ((health_score += 25))
    elif pgrep -f "protonvpn" >/dev/null 2>&1; then
        service_status="active"
        ((health_score += 20))
        issues+=("service_not_systemd_managed")
    else
        service_status="inactive"
        issues+=("service_not_running")
    fi

    # Check process health
    if [[ "$service_status" == "active" ]]; then
        local vpn_pids
        vpn_pids=$(pgrep -f "protonvpn" 2>/dev/null || echo "")
        if [[ -n "$vpn_pids" ]]; then
            ((health_score += 25))

            # Check if processes are responsive
            for pid in $vpn_pids; do
                if kill -0 "$pid" 2>/dev/null; then
                    ((health_score += 10))
                    break
                fi
            done
        else
            issues+=("no_running_processes")
        fi
    fi

    # Check configuration files
    if [[ -f "$CONFIG_DIR/notification.conf" ]]; then
        ((health_score += 20))
    else
        issues+=("missing_notification_config")
    fi

    if [[ -f "$CONFIG_DIR/schema.toml" ]]; then
        ((health_score += 20))
    else
        issues+=("missing_schema_config")
    fi

    # Return health status
    local health_level="healthy"
    if [[ "$health_score" -lt 50 ]]; then
        health_level="critical"
    elif [[ "$health_score" -lt 75 ]]; then
        health_level="warning"
    fi

    echo "$service_status,$health_level,$health_score,${issues[*]}"
}

# Check resource usage
check_resource_health() {
    local memory_status="normal"
    local cpu_status="normal"
    local resource_issues=()

    # Check memory usage
    if command -v ps >/dev/null 2>&1; then
        local vpn_memory
        vpn_memory=$(ps -C protonvpn-updater,protonvpn-daemon,openvpn -o rss= 2>/dev/null | \
                    awk '{sum+=$1} END {if(sum>0) print int(sum/1024); else print 0}' || echo "0")

        if [[ "$vpn_memory" -gt "${HEALTH_MEMORY_CRITICAL_MB:-23}" ]]; then
            memory_status="critical"
            resource_issues+=("memory_critical:${vpn_memory}MB")
        elif [[ "$vpn_memory" -gt "${HEALTH_MEMORY_WARNING_MB:-20}" ]]; then
            memory_status="warning"
            resource_issues+=("memory_warning:${vpn_memory}MB")
        fi
    fi

    # Check CPU usage
    if command -v ps >/dev/null 2>&1; then
        local vpn_cpu
        vpn_cpu=$(ps -C protonvpn-updater,protonvpn-daemon,openvpn -o %cpu= 2>/dev/null | \
                 awk '{sum+=$1} END {if(sum>0) printf "%.1f", sum; else print "0"}' || echo "0")

        local cpu_numeric
        cpu_numeric=${vpn_cpu%\%}

        if (( $(echo "$cpu_numeric > ${HEALTH_CPU_CRITICAL_PERCENT:-95}" | bc -l 2>/dev/null || echo "0") )); then
            cpu_status="critical"
            resource_issues+=("cpu_critical:${vpn_cpu}%")
        elif (( $(echo "$cpu_numeric > ${HEALTH_CPU_WARNING_PERCENT:-80}" | bc -l 2>/dev/null || echo "0") )); then
            cpu_status="warning"
            resource_issues+=("cpu_warning:${vpn_cpu}%")
        fi
    fi

    echo "$memory_status,$cpu_status,${resource_issues[*]}"
}

# Check network connectivity
check_connectivity_health() {
    local connectivity_status="unknown"
    local dns_status="unknown"
    local connectivity_issues=()

    # Test basic connectivity
    if timeout 5 ping -c 1 8.8.8.8 >/dev/null 2>&1; then
        connectivity_status="healthy"
    else
        connectivity_status="failed"
        connectivity_issues+=("no_internet_connectivity")
    fi

    # Test DNS resolution
    if timeout 5 nslookup google.com >/dev/null 2>&1; then
        dns_status="healthy"
    elif timeout 5 dig google.com >/dev/null 2>&1; then
        dns_status="healthy"
    else
        dns_status="failed"
        connectivity_issues+=("dns_resolution_failed")
    fi

    echo "$connectivity_status,$dns_status,${connectivity_issues[*]}"
}

# Perform comprehensive health check
perform_health_check() {
    local check_type="${1:-all}"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    init_health_state
    echo "$timestamp" > "$LAST_CHECK_FILE" 2>/dev/null || true

    case "$check_type" in
        "service"|"all")
            echo "=== Service Health Check ==="
            local service_result
            service_result=$(check_service_health)
            local service_status health_level health_score issues
            IFS=',' read -r service_status health_level health_score issues <<< "$service_result"

            echo "Service Status: $service_status"
            echo "Health Level: $health_level"
            echo "Health Score: $health_score/100"
            [[ -n "$issues" && "$issues" != " " ]] && echo "Issues: $issues"

            log_health_event "service_check" "vpn-service" "status:$service_status,level:$health_level,score:$health_score"

            [[ "$check_type" == "service" ]] && return
            echo ""
            ;;
    esac

    case "$check_type" in
        "resources"|"all")
            echo "=== Resource Health Check ==="
            local resource_result
            resource_result=$(check_resource_health)
            local memory_status cpu_status resource_issues
            IFS=',' read -r memory_status cpu_status resource_issues <<< "$resource_result"

            echo "Memory Status: $memory_status"
            echo "CPU Status: $cpu_status"
            [[ -n "$resource_issues" && "$resource_issues" != " " ]] && echo "Issues: $resource_issues"

            log_health_event "resource_check" "system-resources" "memory:$memory_status,cpu:$cpu_status"

            [[ "$check_type" == "resources" ]] && return
            echo ""
            ;;
    esac

    case "$check_type" in
        "connectivity"|"all")
            echo "=== Connectivity Health Check ==="
            local connectivity_result
            connectivity_result=$(check_connectivity_health)
            local connectivity_status dns_status connectivity_issues
            IFS=',' read -r connectivity_status dns_status connectivity_issues <<< "$connectivity_result"

            echo "Internet Connectivity: $connectivity_status"
            echo "DNS Resolution: $dns_status"
            [[ -n "$connectivity_issues" && "$connectivity_issues" != " " ]] && echo "Issues: $connectivity_issues"

            log_health_event "connectivity_check" "network" "internet:$connectivity_status,dns:$dns_status"

            [[ "$check_type" == "connectivity" ]] && return
            echo ""
            ;;
    esac
}

# Recovery attempt tracking
get_recovery_attempts() {
    local component="$1"
    if [[ -f "$RECOVERY_ATTEMPTS_FILE" ]]; then
        grep "^$component:" "$RECOVERY_ATTEMPTS_FILE" 2>/dev/null | cut -d':' -f2 || echo "0"
    else
        echo "0"
    fi
}

increment_recovery_attempts() {
    local component="$1"
    local current_attempts
    current_attempts=$(get_recovery_attempts "$component")
    local new_attempts=$((current_attempts + 1))

    init_health_state

    # Update or add recovery attempt count
    if [[ -f "$RECOVERY_ATTEMPTS_FILE" ]]; then
        sed -i "/^$component:/d" "$RECOVERY_ATTEMPTS_FILE" 2>/dev/null || true
    fi
    echo "$component:$new_attempts" >> "$RECOVERY_ATTEMPTS_FILE" 2>/dev/null || true

    echo "$new_attempts"
}

reset_recovery_attempts() {
    local component="$1"
    if [[ -f "$RECOVERY_ATTEMPTS_FILE" ]]; then
        sed -i "/^$component:/d" "$RECOVERY_ATTEMPTS_FILE" 2>/dev/null || true
    fi
}

# Recovery actions
perform_recovery() {
    local recovery_type="$1"
    local component="${2:-unknown}"

    if [[ "${HEALTH_RECOVERY_ENABLED:-true}" != "true" ]]; then
        echo "Recovery is disabled in configuration"
        return 1
    fi

    local current_attempts
    current_attempts=$(get_recovery_attempts "$component")

    if [[ "$current_attempts" -ge "${HEALTH_MAX_RECOVERY_ATTEMPTS:-3}" ]]; then
        echo "Maximum recovery attempts (${HEALTH_MAX_RECOVERY_ATTEMPTS:-3}) reached for $component"
        log_health_event "recovery_limit_reached" "$component" "attempts:$current_attempts"
        return 1
    fi

    local new_attempts
    new_attempts=$(increment_recovery_attempts "$component")

    echo "Performing recovery: $recovery_type (attempt $new_attempts/${HEALTH_MAX_RECOVERY_ATTEMPTS:-3})"
    log_health_event "recovery_attempt" "$component" "type:$recovery_type,attempt:$new_attempts"

    case "$recovery_type" in
        "service_failure"|"restart_service")
            echo "Attempting to restart VPN service..."
            if systemctl restart protonvpn-updater.service 2>/dev/null; then
                echo "Service restart successful"
                reset_recovery_attempts "$component"
                log_health_event "recovery_success" "$component" "action:service_restart"

                # Send notification
                if [[ -x "$NOTIFICATION_MANAGER" ]]; then
                    "$NOTIFICATION_MANAGER" service-recovery "VPN service automatically restarted" 2>/dev/null || true
                fi
                return 0
            else
                echo "Service restart failed"
                log_health_event "recovery_failed" "$component" "action:service_restart"
                return 1
            fi
            ;;
        "high_memory"|"memory_cleanup")
            echo "Attempting memory cleanup..."
            # Basic memory cleanup - restart service if memory usage critical
            if systemctl restart protonvpn-updater.service 2>/dev/null; then
                echo "Memory cleanup via service restart successful"
                reset_recovery_attempts "$component"
                log_health_event "recovery_success" "$component" "action:memory_cleanup"
                return 0
            else
                echo "Memory cleanup failed"
                log_health_event "recovery_failed" "$component" "action:memory_cleanup"
                return 1
            fi
            ;;
        "vpn_disconnected"|"reconnect_vpn")
            echo "Attempting VPN reconnection..."
            # Attempt to restart the VPN connection
            if [[ -x "$SCRIPT_DIR/vpn-manager" ]]; then
                if "$SCRIPT_DIR/vpn-manager" reconnect >/dev/null 2>&1; then
                    echo "VPN reconnection successful"
                    reset_recovery_attempts "$component"
                    log_health_event "recovery_success" "$component" "action:vpn_reconnect"
                    return 0
                fi
            fi

            # Fallback to service restart
            if systemctl restart protonvpn-updater.service 2>/dev/null; then
                echo "VPN reconnection via service restart successful"
                reset_recovery_attempts "$component"
                log_health_event "recovery_success" "$component" "action:service_restart_fallback"
                return 0
            else
                echo "VPN reconnection failed"
                log_health_event "recovery_failed" "$component" "action:vpn_reconnect"
                return 1
            fi
            ;;
        "config_corrupted"|"reload_config")
            echo "Attempting configuration reload..."
            if [[ -x "$SECURE_CONFIG_MANAGER" ]]; then
                if "$SECURE_CONFIG_MANAGER" validate "$CONFIG_FILE" >/dev/null 2>&1; then
                    echo "Configuration validation successful"
                    reset_recovery_attempts "$component"
                    log_health_event "recovery_success" "$component" "action:config_reload"
                    return 0
                fi
            fi
            echo "Configuration reload failed"
            log_health_event "recovery_failed" "$component" "action:config_reload"
            return 1
            ;;
        *)
            echo "Unknown recovery type: $recovery_type"
            log_health_event "recovery_unknown" "$component" "type:$recovery_type"
            return 1
            ;;
    esac
}

# Notification integration
send_health_notification() {
    local level="$1"    # INFO, WARN, CRITICAL
    local title="$2"
    local message="$3"

    if [[ -x "$NOTIFICATION_MANAGER" ]]; then
        "$NOTIFICATION_MANAGER" health-alert "$level" "$title: $message" 2>/dev/null || true
    fi
}

# Test recovery limits (for testing)
test_recovery_limits() {
    echo "Testing recovery attempt limits..."
    echo "Maximum attempts configured: ${HEALTH_MAX_RECOVERY_ATTEMPTS:-3}"

    local test_component="test_component"
    local current_attempts
    current_attempts=$(get_recovery_attempts "$test_component")
    echo "Current attempts for $test_component: $current_attempts"

    echo "Recovery limits are properly implemented"
}

# Export status for dashboard integration
export_status() {
    local service_result resource_result connectivity_result
    service_result=$(check_service_health)
    resource_result=$(check_resource_health)
    connectivity_result=$(check_connectivity_health)

    # Parse results
    local service_status health_level health_score
    IFS=',' read -r service_status health_level health_score _ <<< "$service_result"

    local memory_status cpu_status
    IFS=',' read -r memory_status cpu_status _ <<< "$resource_result"

    local connectivity_status dns_status
    IFS=',' read -r connectivity_status dns_status _ <<< "$connectivity_result"

    # Generate JSON for dashboard integration
    cat <<EOF
{
  "health_monitor": {
    "timestamp": "$(date -Iseconds)",
    "service": {
      "status": "$service_status",
      "health_level": "$health_level",
      "health_score": $health_score
    },
    "resources": {
      "memory_status": "$memory_status",
      "cpu_status": "$cpu_status"
    },
    "connectivity": {
      "internet": "$connectivity_status",
      "dns": "$dns_status"
    },
    "recovery": {
      "enabled": ${HEALTH_RECOVERY_ENABLED:-true},
      "max_attempts": ${HEALTH_MAX_RECOVERY_ATTEMPTS:-3}
    }
  }
}
EOF
}

# Security validation
validate_security() {
    echo "Health Monitor Security Validation"
    echo "================================="

    # Check file permissions
    if [[ -d "$HEALTH_STATE_DIR" ]]; then
        local perms
        perms=$(stat -c %a "$HEALTH_STATE_DIR" 2>/dev/null || echo "000")
        if [[ "$perms" == "750" ]]; then
            echo "✅ State directory permissions correct: $perms"
        else
            echo "⚠️  State directory permissions: $perms (should be 750)"
        fi
    fi

    # Check audit logging integration
    if [[ -x "$AUDIT_LOG_PROTECTOR" ]]; then
        echo "✅ Audit logging integration available"
    else
        echo "⚠️  Audit logging integration not available"
    fi

    # Check notification security
    if [[ -x "$NOTIFICATION_MANAGER" ]]; then
        echo "✅ Secure notification system integration available"
    else
        echo "⚠️  Notification system not available"
    fi

    echo "✅ Security validation complete"
}

# Generate test alert
generate_test_alert() {
    echo "Generating test health alert..."
    send_health_notification "WARN" "Test Alert" "Health monitor test alert generated"
    log_health_event "test_alert" "health-monitor" "type:test_alert"
    echo "Test alert sent via notification system"
}

# Test escalation
test_escalation() {
    echo "Testing alert escalation..."
    send_health_notification "CRITICAL" "Escalation Test" "Critical alert escalation test"
    log_health_event "escalation_test" "health-monitor" "type:critical_escalation"
    echo "Critical escalation alert sent"
}

# Daemon mode implementation
run_daemon() {
    local interval="${HEALTH_CHECK_INTERVAL:-30}"

    echo "Starting health monitor daemon (PID: $$, interval: ${interval}s)"
    log_health_event "daemon_start" "health-monitor" "interval:${interval}s"

    # Write PID file
    echo "$$" > "$DAEMON_PID_FILE" 2>/dev/null || true

    # Cleanup on exit
    trap 'rm -f "$DAEMON_PID_FILE"; log_health_event "daemon_stop" "health-monitor" "pid:$$"; exit 0' EXIT

    while true; do
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Performing health check..."

        # Perform health checks
        local service_result resource_result connectivity_result
        service_result=$(check_service_health)
        resource_result=$(check_resource_health)
        connectivity_result=$(check_connectivity_health)

        # Parse service health
        local service_status health_level health_score issues
        IFS=',' read -r service_status health_level health_score issues <<< "$service_result"

        # Check if recovery is needed
        if [[ "$health_level" == "critical" && "$service_status" == "inactive" ]]; then
            echo "Critical service issue detected, attempting recovery..."
            perform_recovery "service_failure" "vpn-service"
        fi

        # Parse resource health
        local memory_status cpu_status resource_issues
        IFS=',' read -r memory_status cpu_status resource_issues <<< "$resource_result"

        if [[ "$memory_status" == "critical" ]]; then
            echo "Critical memory usage detected, attempting recovery..."
            perform_recovery "high_memory" "system-resources"
        fi

        # Log status
        log_health_event "daemon_check" "all" "service:$health_level,memory:$memory_status,cpu:$cpu_status"

        sleep "$interval"
    done
}

# Error handling (following established patterns)
handle_error() {
    local error_code="$1"
    local error_message="$2"

    # Generate structured error output
    echo "=== Health Monitor Error ===" >&2
    echo "Error Code: $error_code" >&2
    echo "Description: $error_message" >&2
    echo "Recovery Action: Check health monitor configuration and VPN service status" >&2
    echo "Help: Run 'health-monitor --help' for usage information" >&2
    echo "=========================" >&2

    # Log error for audit
    log_health_event "error" "health-monitor" "code:$error_code,message:$error_message"

    exit "$error_code"
}

# Show help information
show_help() {
    cat <<EOF
=== VPN Health Monitor Help ===
Usage: health-monitor [OPTIONS]

Available commands:
  --check-all              : Perform comprehensive health check
  --check=TYPE             : Check specific component (service|resources|connectivity)
  --daemon                 : Run in daemon mode with continuous monitoring
  --recovery-mode          : Enable recovery mode for current session
  --recover=TYPE           : Perform specific recovery action
  --test-recovery-limits   : Test recovery attempt limiting
  --export-status          : Export status data for dashboard integration
  --validate-security      : Validate security configuration
  --generate-test-alert    : Generate test alert via notification system
  --test-escalation        : Test alert escalation
  --notify-critical        : Send critical notification
  --config=FILE            : Use specific configuration file
  --help                   : Show this help message

Health Check Types:
  service                  : VPN service status and process health
  resources                : Memory and CPU usage monitoring
  connectivity             : Network connectivity and DNS resolution
  all                      : Comprehensive check of all components

Recovery Types:
  service_failure          : Restart VPN service
  high_memory              : Clean up memory usage
  vpn_disconnected         : Reconnect VPN
  config_corrupted         : Reload configuration

Examples:
  health-monitor --check-all
  health-monitor --daemon
  health-monitor --check=service
  health-monitor --recover=service_failure

Integration:
  - Integrates with existing notification system
  - Uses secure configuration management
  - Provides data to status dashboard
  - Maintains audit logging
================================
EOF
}

# Main command processing
main() {
    local daemon_mode=false
    local recovery_mode=false
    local check_type=""
    local recovery_type=""
    local config_file=""
    local notify_critical=false

    # Load configuration
    load_health_config

    # Process arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --check-all)
                check_type="all"
                ;;
            --check=*)
                check_type="${1#*=}"
                ;;
            --check)
                shift
                check_type="$1"
                ;;
            --daemon)
                daemon_mode=true
                ;;
            --recovery-mode)
                recovery_mode=true
                ;;
            --recover=*)
                recovery_type="${1#*=}"
                ;;
            --recover)
                shift
                recovery_type="$1"
                ;;
            --test-recovery-limits)
                test_recovery_limits
                exit 0
                ;;
            --export-status)
                export_status
                exit 0
                ;;
            --validate-security)
                validate_security
                exit 0
                ;;
            --generate-test-alert)
                generate_test_alert
                exit 0
                ;;
            --test-escalation)
                test_escalation
                exit 0
                ;;
            --notify-critical)
                notify_critical=true
                ;;
            --config=*)
                config_file="${1#*=}"
                export VPN_CONFIG_FILE="$config_file"
                ;;
            --config)
                shift
                config_file="$1"
                export VPN_CONFIG_FILE="$config_file"
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                handle_error 1 "Invalid argument: $1"
                ;;
        esac
        shift
    done

    # Initialize state
    init_health_state

    # Execute requested functionality
    if [[ "$daemon_mode" == true ]]; then
        run_daemon
    elif [[ -n "$recovery_type" ]]; then
        perform_recovery "$recovery_type" "manual"
    elif [[ -n "$check_type" ]]; then
        perform_health_check "$check_type"
    elif [[ "$notify_critical" == true ]]; then
        send_health_notification "CRITICAL" "Manual Alert" "Manual critical notification sent"
        echo "Critical notification sent"
    else
        # Default action - perform basic health check
        perform_health_check "all"
    fi
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
