#!/bin/bash
# ABOUTME: ProtonVPN Service Management Script
# ABOUTME: Handles logging, PID management, and service lifecycle for production deployment

set -euo pipefail

# Production paths
readonly VPN_LOG_DIR="/var/log/protonvpn"
readonly VPN_RUN_DIR="/run/protonvpn"
readonly VPN_CONFIG_DIR="/etc/protonvpn"
# shellcheck disable=SC2034  # SYSTEMD_DIR reserved for systemd integration
readonly SYSTEMD_DIR="/etc/systemd/system"

# Service configuration
readonly VPN_USER="protonvpn"
readonly VPN_GROUP="protonvpn"
readonly SERVICES=("protonvpn-daemon" "protonvpn-health-monitor" "protonvpn-api-server" "protonvpn-notification")
readonly SERVICE_DIR="/etc/service"

# Input validation functions
validate_service_name() {
	local service="$1"

	# Allow 'all' or valid service names
	if [[ "$service" == "all" ]]; then
		return 0
	fi

	# Validate service name against known services
	local valid_service=false
	for svc in "${SERVICES[@]}"; do
		if [[ "$service" == "$svc" ]]; then
			valid_service=true
			break
		fi
	done

	if [[ "$valid_service" == "false" ]]; then
		log_error "Invalid service name: $service"
		log_error "Valid services: all, ${SERVICES[*]}"
		return 1
	fi

	# Additional regex validation for security
	if [[ ! "$service" =~ ^[a-zA-Z0-9][a-zA-Z0-9._-]*$ ]]; then
		log_error "Service name contains invalid characters: $service"
		return 1
	fi

	return 0
}

# Logging functions with input sanitization
sanitize_log_input() {
	local input="$*"
	# Remove ANSI escape sequences, newlines, and control characters
	printf '%s' "$input" | tr -d '\r\n\t\033' | sed 's/\x1b\[[0-9;]*m//g'
}

log_info() {
	local sanitized_message
	sanitized_message=$(sanitize_log_input "$*")
	echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $sanitized_message" | tee -a "$VPN_LOG_DIR/service-manager.log"
}

log_error() {
	local sanitized_message
	sanitized_message=$(sanitize_log_input "$*")
	echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $sanitized_message" | tee -a "$VPN_LOG_DIR/service-manager.log" >&2
}

log_warn() {
	local sanitized_message
	sanitized_message=$(sanitize_log_input "$*")
	echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARN: $sanitized_message" | tee -a "$VPN_LOG_DIR/service-manager.log"
}

# Check if running as root
check_root() {
	if [[ $EUID -ne 0 ]]; then
		log_error "This script must be run as root"
		echo "Usage: sudo $0 <command>"
		exit 1
	fi
}

# Initialize logging and PID directories
init_directories() {
	log_info "Initializing service directories..."

	# Create directories if they don't exist
	mkdir -p "$VPN_LOG_DIR" "$VPN_RUN_DIR"

	# Set proper ownership and permissions
	chown "$VPN_USER:$VPN_GROUP" "$VPN_LOG_DIR" "$VPN_RUN_DIR"
	chmod 0750 "$VPN_LOG_DIR"
	chmod 0755 "$VPN_RUN_DIR"

	# Create service manager log
	touch "$VPN_LOG_DIR/service-manager.log"
	chown "$VPN_USER:$VPN_GROUP" "$VPN_LOG_DIR/service-manager.log"
	chmod 0640 "$VPN_LOG_DIR/service-manager.log"

	log_info "Service directories initialized successfully"
}

# Setup log rotation
setup_log_rotation() {
	log_info "Setting up log rotation..."

	cat >/etc/logrotate.d/protonvpn <<'EOF'
/var/log/protonvpn/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 0640 protonvpn protonvpn
    postrotate
        systemctl reload protonvpn.target 2>/dev/null || true
    endscript
}
EOF

	log_info "Log rotation configured"
}

# Service status functions
service_status() {
	local service="${1:-all}"

	if [[ "$service" == "all" ]]; then
		log_info "Checking status of all ProtonVPN services..."

		for svc in "${SERVICES[@]}"; do
			local service_path="$SERVICE_DIR/$svc"
			echo "--- $svc ---"

			if [[ -L "$service_path" ]]; then
				echo "Enabled: Yes (symlink exists)"
				if sv status "$service_path" 2>/dev/null; then
					echo "Status: Running"
				else
					echo "Status: Not running"
				fi
			else
				echo "Enabled: No (no symlink in $SERVICE_DIR)"
				echo "Status: Not available"
			fi
			echo ""
		done
	else
		log_info "Checking status of $service..."
		local service_path="$SERVICE_DIR/$service"

		if [[ -L "$service_path" ]]; then
			echo "Service: $service"
			echo "Enabled: Yes"
			sv status "$service_path" 2>/dev/null || echo "Status: Not running"
		else
			echo "Service: $service"
			echo "Enabled: No (no symlink in $SERVICE_DIR)"
			echo "Status: Not available"
		fi
	fi
}

# Start services
start_services() {
	local service="${1:-all}"

	# Validate service name first
	if ! validate_service_name "$service"; then
		return 1
	fi

	init_directories

	if [[ "$service" == "all" ]]; then
		log_info "Starting all ProtonVPN services..."
		local failed_services=0

		for svc in "${SERVICES[@]}"; do
			local service_path="$SERVICE_DIR/$svc"
			if [[ -L "$service_path" ]]; then
				log_info "Starting service: $svc"
				if sv up "$service_path" >/dev/null 2>&1; then
					log_info "Service $svc started successfully"
				else
					log_error "Failed to start service: $svc"
					((failed_services++))
				fi
			else
				log_warn "Service not enabled: $svc (no symlink in $SERVICE_DIR)"
			fi
		done

		if [[ $failed_services -eq 0 ]]; then
			log_info "All ProtonVPN services started successfully"
		else
			log_error "Failed to start $failed_services services"
			exit 1
		fi
	else
		log_info "Starting service: $service"
		local service_path="$SERVICE_DIR/$service"

		if [[ ! -L "$service_path" ]]; then
			log_error "Service not enabled: $service (no symlink in $SERVICE_DIR)"
			exit 1
		fi

		if sv up "$service_path" >/dev/null 2>&1; then
			log_info "Service $service started successfully"
		else
			log_error "Failed to start service: $service"
			exit 1
		fi
	fi
}

# Stop services
stop_services() {
	local service="${1:-all}"

	# Validate service name first
	if ! validate_service_name "$service"; then
		return 1
	fi

	if [[ "$service" == "all" ]]; then
		log_info "Stopping all ProtonVPN services..."
		local failed_services=0

		for svc in "${SERVICES[@]}"; do
			local service_path="$SERVICE_DIR/$svc"
			if [[ -L "$service_path" ]]; then
				log_info "Stopping service: $svc"
				if sv down "$service_path" >/dev/null 2>&1; then
					log_info "Service $svc stopped successfully"
				else
					log_error "Failed to stop service: $svc"
					((failed_services++))
				fi
			else
				log_info "Service not enabled: $svc (skipping)"
			fi
		done

		if [[ $failed_services -eq 0 ]]; then
			log_info "All ProtonVPN services stopped successfully"
		else
			log_warn "$failed_services services failed to stop cleanly"
		fi
	else
		log_info "Stopping service: $service"
		local service_path="$SERVICE_DIR/$service"

		if [[ ! -L "$service_path" ]]; then
			log_error "Service not enabled: $service (no symlink in $SERVICE_DIR)"
			exit 1
		fi

		if sv down "$service_path" >/dev/null 2>&1; then
			log_info "Service $service stopped successfully"
		else
			log_error "Failed to stop service: $service"
			exit 1
		fi
	fi
}

# Restart services
restart_services() {
	local service="${1:-all}"

	# Validate service name first
	if ! validate_service_name "$service"; then
		return 1
	fi

	log_info "Restarting ProtonVPN services..."
	stop_services "$service"
	sleep 1
	start_services "$service"
}

# Enable services at boot
enable_services() {
	log_info "Enabling ProtonVPN services at boot..."

	# Ensure /etc/service directory exists
	if [[ ! -d "$SERVICE_DIR" ]]; then
		mkdir -p "$SERVICE_DIR"
		log_info "Created service directory: $SERVICE_DIR"
	fi

	for svc in "${SERVICES[@]}"; do
		local service_source="/etc/sv/$svc"
		local service_link="$SERVICE_DIR/$svc"

		if [[ -d "$service_source" ]]; then
			if [[ ! -L "$service_link" ]]; then
				ln -sf "$service_source" "$service_link"
				log_info "Enabled service: $svc"
			else
				log_info "Service already enabled: $svc"
			fi
		else
			log_error "Service definition not found: $service_source"
		fi
	done

	log_info "Services enabled at boot"
}

# Disable services at boot
disable_services() {
	log_info "Disabling ProtonVPN services at boot..."

	for svc in "${SERVICES[@]}"; do
		local service_link="$SERVICE_DIR/$svc"

		if [[ -L "$service_link" ]]; then
			# Stop service first
			sv down "$service_link" 2>/dev/null || true
			# Remove symlink
			rm -f "$service_link"
			log_info "Disabled service: $svc"
		else
			log_info "Service already disabled: $svc"
		fi
	done

	log_info "Services disabled at boot"
}

# Clean up PID and log files
cleanup() {
	log_info "Cleaning up service files..."

	# Validate signal source (prevent signal injection attacks)
	if [[ "${BASH_SUBSHELL}" -gt 0 ]]; then
		log_warn "Cleanup called from subshell - potential signal injection"
		return 1
	fi

	# Stop all services first with timeout
	if ! timeout 30 stop_services "all" 2>/dev/null; then
		log_warn "Service stop timed out, forcing cleanup"
	fi

	# Verify processes are stopped before removing PID files
	for svc in "${SERVICES[@]}"; do
		if systemctl is-active --quiet "$svc" 2>/dev/null; then
			log_warn "Service $svc still running during cleanup"
		fi
	done

	# Remove PID files safely
	if [[ -d "$VPN_RUN_DIR" ]]; then
		find "$VPN_RUN_DIR" -name "*.pid" -type f -delete 2>/dev/null || true
	fi

	# Clean old logs (keep last 3 days) with size limit check
	if [[ -d "$VPN_LOG_DIR" ]]; then
		find "$VPN_LOG_DIR" -name "*.log.*" -mtime +3 -size +100M -delete 2>/dev/null || true
	fi

	log_info "Cleanup completed"
}

# Health check
health_check() {
	log_info "Performing health check..."

	local issues=0

	# Check if directories exist with correct permissions
	for dir in "$VPN_LOG_DIR" "$VPN_RUN_DIR" "$VPN_CONFIG_DIR"; do
		if [[ ! -d "$dir" ]]; then
			log_error "Directory missing: $dir"
			((issues++))
		fi
	done

	# Check service status
	for svc in "${SERVICES[@]}"; do
		local service_path="$SERVICE_DIR/$svc"
		if [[ -L "$service_path" ]]; then
			if ! sv status "$service_path" >/dev/null 2>&1; then
				log_warn "Service not running: $svc"
				((issues++))
			fi
		else
			log_warn "Service not enabled: $svc"
			((issues++))
		fi
	done

	# Check log files
	if [[ ! -f "$VPN_LOG_DIR/service-manager.log" ]]; then
		log_error "Service manager log missing"
		((issues++))
	fi

	if [[ $issues -eq 0 ]]; then
		log_info "Health check passed - all systems operational"
		return 0
	else
		log_error "Health check failed - $issues issues found"
		return 1
	fi
}

# Show usage
usage() {
	cat <<'EOF'
ProtonVPN Service Manager

Usage: protonvpn-service-manager <command> [service]

Commands:
    start [service]     - Start services (default: all)
    stop [service]      - Stop services (default: all)
    restart [service]   - Restart services (default: all)
    status [service]    - Show service status (default: all)
    enable              - Enable services at boot
    disable             - Disable services at boot
    health              - Perform health check
    cleanup             - Clean up PID and log files
    init                - Initialize directories and logging
    logs [service]      - Show recent logs

Services:
    all (default)
    protonvpn-daemon
    protonvpn-health-monitor
    protonvpn-api-server
    protonvpn-notification

Examples:
    protonvpn-service-manager start
    protonvpn-service-manager stop protonvpn-daemon
    protonvpn-service-manager status
    protonvpn-service-manager health
EOF
}

# Show logs
show_logs() {
	local service="${1:-all}"

	if [[ "$service" == "all" ]]; then
		log_info "Showing recent logs for all services..."
		journalctl -u protonvpn.target --since "1 hour ago" --no-pager
	else
		log_info "Showing recent logs for $service..."
		journalctl -u "$service" --since "1 hour ago" --no-pager
	fi
}

# Main function
main() {
	local command="${1:-help}"
	local service="${2:-all}"

	case "$command" in
	start)
		check_root
		start_services "$service"
		;;
	stop)
		check_root
		stop_services "$service"
		;;
	restart)
		check_root
		restart_services "$service"
		;;
	status)
		service_status "$service"
		;;
	enable)
		check_root
		enable_services
		;;
	disable)
		check_root
		disable_services
		;;
	health)
		health_check
		;;
	cleanup)
		check_root
		cleanup
		;;
	init)
		check_root
		init_directories
		setup_log_rotation
		;;
	logs)
		show_logs "$service"
		;;
	help | --help | -h)
		usage
		;;
	*)
		log_error "Unknown command: $command"
		usage
		exit 1
		;;
	esac
}

# Run main function with all arguments
main "$@"
